{"version":3,"sources":["string.js"],"names":["string","str1","str2","test1","String","toLowerCase","test2","str","replace","x","Math","floor","random","toString","abs","Date","now","val","hash","i","len","length","charCodeAt","start","end","value","substring"],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAEMA,M;;;;;;;0CAQyBC,I,EAAMC,I,EAAM;AACzC,QAAMC,QAAQC,OAAOH,IAAP,EAAaI,WAAb,EAAd;AACA,QAAMC,QAAQF,OAAOF,IAAP,EAAaG,WAAb,EAAd;;AAEA,QAAIF,QAAQG,KAAZ,EAAmB;AAClB,YAAO,CAAC,CAAR;AACA,KAFD,MAEO,IAAIH,UAAUG,KAAd,EAAqB;AAC3B,YAAO,CAAP;AACA,KAFM,MAEA;AACN,YAAO,CAAP;AACA;AACD;;;0CAS6BC,G,EAAK;AAClC,WAAOA,IAAIC,OAAJ,CAAY,aAAZ,EAA2B,GAA3B,EAAgCA,OAAhC,CAAwC,0BAAxC,EAAoE,EAApE,CAAP;AACA;;;+BAQkBD,G,EAAK;AACvB,WAAOH,OAAOG,GAAP,EACLC,OADK,CACG,+BADH,EACoC,MADpC,EAELA,OAFK,CAEG,OAFH,EAEY,OAFZ,CAAP;AAGA;;;qCAMwB;AACxB,QAAMC,IAAI,UAAV;AACA,WAAOC,KAAKC,KAAL,CAAWD,KAAKE,MAAL,KAAgBH,CAA3B,EAA8BI,QAA9B,CAAuC,EAAvC,IACNH,KAAKI,GAAL,CAASJ,KAAKC,KAAL,CAAWD,KAAKE,MAAL,KAAgBH,CAA3B,IAAgCM,KAAKC,GAAL,EAAzC,EAAqDH,QAArD,CAA8D,EAA9D,CADD;AAEA;;;4BAWeI,G,EAAK;AACpB,QAAIC,OAAO,CAAX;AACA,SAAK,IAAIC,IAAI,CAAR,EAAWC,MAAMH,IAAII,MAA1B,EAAkCF,IAAIC,GAAtC,EAA2CD,GAA3C,EAAgD;AAC/CD,YAAO,KAAKA,IAAL,GAAYD,IAAIK,UAAJ,CAAeH,CAAf,CAAnB;AACAD,aAAQ,WAAR;AACA;AACD,WAAOA,IAAP;AACA;;;mCAWsBX,G,EAAKgB,K,EAAOC,G,EAAKC,K,EAAO;AAC9C,WAAOlB,IAAImB,SAAJ,CAAc,CAAd,EAAiBH,KAAjB,IAA0BE,KAA1B,GAAkClB,IAAImB,SAAJ,CAAcF,GAAd,CAAzC;AACA;;;;;;mBAGaxB,M","file":"string.js","sourcesContent":["'use strict';\n\nclass string {\n\t/**\n\t * Compares the given strings without taking the case into account.\n\t * @param {string|number} str1\n\t * @param {string|number} str2\n\t * @return {number} Either -1, 0 or 1, according to if the first string is\n\t *     \"smaller\", equal or \"bigger\" than the second given string.\n\t */\n\tstatic caseInsensitiveCompare(str1, str2) {\n\t\tconst test1 = String(str1).toLowerCase();\n\t\tconst test2 = String(str2).toLowerCase();\n\n\t\tif (test1 < test2) {\n\t\t\treturn -1;\n\t\t} else if (test1 === test2) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/**\n\t * Removes the breaking spaces from the left and right of the string and\n\t * collapses the sequences of breaking spaces in the middle into single spaces.\n\t * The original and the result strings render the same way in HTML.\n\t * @param {string} str A string in which to collapse spaces.\n\t * @return {string} Copy of the string with normalized breaking spaces.\n\t */\n\tstatic collapseBreakingSpaces(str) {\n\t\treturn str.replace(/[\\t\\r\\n ]+/g, ' ').replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, '');\n\t}\n\n\t/**\n\t* Escapes characters in the string that are not safe to use in a RegExp.\n\t* @param {*} str The string to escape. If not a string, it will be casted\n\t*     to one.\n\t* @return {string} A RegExp safe, escaped copy of {@code s}.\n\t*/\n\tstatic escapeRegex(str) {\n\t\treturn String(str)\n\t\t\t.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1')\n\t\t\t.replace(/\\x08/g, '\\\\x08');\n\t}\n\n\t/**\n\t* Returns a string with at least 64-bits of randomness.\n\t* @return {string} A random string, e.g. sn1s7vb4gcic.\n\t*/\n\tstatic getRandomString() {\n\t\tconst x = 2147483648;\n\t\treturn Math.floor(Math.random() * x).toString(36) +\n\t\t\tMath.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);\n\t}\n\n\t/**\n\t * Calculates the hashcode for a string. The hashcode value is computed by\n\t * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice\n\t * property of using 31 prime is that the multiplication can be replaced by\n\t * a shift and a subtraction for better performance: 31*i == (i<<5)-i.\n\t * Modern VMs do this sort of optimization automatically.\n\t * @param {String} val Target string.\n\t * @return {Number} Returns the string hashcode.\n\t */\n\tstatic hashCode(val) {\n\t\tlet hash = 0;\n\t\tfor (let i = 0, len = val.length; i < len; i++) {\n\t\t\thash = 31 * hash + val.charCodeAt(i);\n\t\t\thash %= 0x100000000;\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**\n\t * Replaces interval into the string with specified value, e.g.\n\t * `replaceInterval(\"abcde\", 1, 4, \"\")` returns \"ae\".\n\t * @param {string} str The input string.\n\t * @param {Number} start Start interval position to be replaced.\n\t * @param {Number} end End interval position to be replaced.\n\t * @param {string} value The value that replaces the specified interval.\n\t * @return {string}\n\t */\n\tstatic replaceInterval(str, start, end, value) {\n\t\treturn str.substring(0, start) + value + str.substring(end);\n\t}\n}\n\nexport default string;\n"]}