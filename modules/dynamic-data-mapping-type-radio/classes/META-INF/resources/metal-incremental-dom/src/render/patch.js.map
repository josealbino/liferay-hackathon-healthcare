{"version":3,"sources":["patch.js"],"names":["getPatchingComponent","patch","patchingComponents_","buildParentIfNecessary_","element","parentNode","parent","document","createElement","callPatch_","component","opt_outer","push","data","render","bind","patchFn","IncrementalDOM","patchOuter","pop","length","tryPatchEmptyWithParent_","tryPatchWithNoParent_","getRenderer","tempParent","inDocument","attach","getAttachData","attachElement","sibling"],"mappings":";AAAA;;;;;SAoDgBA,oB,GAAAA,oB;SAQAC,K,GAAAA,K;;;AAtDhB,KAAMC,sBAAsB,EAA5B;;AAEA;;;;;;;AAOA,UAASC,uBAAT,CAAiCC,OAAjC,EAA0C;AACzC,MAAI,CAACA,OAAD,IAAY,CAACA,QAAQC,UAAzB,EAAqC;AACpC,OAAMC,SAASC,SAASC,aAAT,CAAuB,KAAvB,CAAf;AACA,OAAIJ,OAAJ,EAAa;AACZ,qBAAOE,MAAP,EAAeF,OAAf;AACA;AACD,UAAOE,MAAP;AACA;AACD;;AAED;;;;;;;;AAQA,UAASG,UAAT,CAAoBC,SAApB,EAA+BN,OAA/B,EAAwCO,SAAxC,EAAmD;AAClDT,sBAAoBU,IAApB,CAAyBF,SAAzB;;AAEA,MAAMG,OAAO,mBAAQH,SAAR,CAAb;AACA,MAAI,CAACG,KAAKC,MAAV,EAAkB;AACjB;AACAD,QAAKC,MAAL,GAAc,eAAOC,IAAP,CAAY,IAAZ,EAAkBL,SAAlB,CAAd;AACA;;AAED,MAAMM,UAAUL,YAAYM,eAAeC,UAA3B,GAAwCD,eAAehB,KAAvE;AACAe,UAAQZ,OAAR,EAAiBS,KAAKC,MAAtB;;AAEAZ,sBAAoBiB,GAApB;AACA;;AAED;;;;AAIO,UAASnB,oBAAT,GAAgC;AACtC,SAAOE,oBAAoBA,oBAAoBkB,MAApB,GAA6B,CAAjD,CAAP;AACA;;AAED;;;;AAIO,UAASnB,KAAT,CAAeS,SAAf,EAA0B;AAChC,MAAI,CAACW,yBAAyBX,SAAzB,CAAL,EAA0C;AACzC,OAAI,CAACY,sBAAsBZ,SAAtB,CAAL,EAAuC;AACtC,QAAMN,UAAUM,UAAUN,OAA1B;AACAK,eAAWC,SAAX,EAAsBN,OAAtB,EAA+B,IAA/B;AACA;AACD;AACD;;AAED;;;;;;;;AAQA,UAASiB,wBAAT,CAAkCX,SAAlC,EAA6C;AAC5C,MAAMG,OAAO,mBAAQH,SAAR,CAAb;AACA,MAAI,CAACA,UAAUN,OAAX,IAAsBS,KAAKP,MAA/B,EAAuC;AACtCO,QAAKP,MAAL,CAAYiB,WAAZ,GAA0BtB,KAA1B,CAAgCY,KAAKP,MAArC;AACA,UAAO,IAAP;AACA;AACD;;AAED;;;;;;;;;;AAUA,UAASgB,qBAAT,CAA+BZ,SAA/B,EAA0C;AACzC,MAAMc,aAAarB,wBAAwBO,UAAUN,OAAlC,CAAnB;AACA,MAAIoB,UAAJ,EAAgB;AACff,cAAWC,SAAX,EAAsBc,UAAtB;AACA,0BAAad,UAAUN,OAAvB;AACA,OAAIM,UAAUN,OAAV,IAAqBM,UAAUe,UAAnC,EAA+C;AAC9C,QAAMC,SAAShB,UAAUiB,aAAV,EAAf;AACAjB,cAAUkB,aAAV,CAAwBF,OAAOpB,MAA/B,EAAuCoB,OAAOG,OAA9C;AACA;AACD,UAAO,IAAP;AACA;AACD","file":"patch.js","sourcesContent":["'use strict';\n\nimport { append, exitDocument } from 'metal-dom';\nimport { getData } from '../data';\nimport { render } from './render';\n\nconst patchingComponents_ = [];\n\n/**\n * Guarantees that the component's element has a parent. That's necessary\n * when calling incremental dom's `patchOuter` for now, as otherwise it will\n * throw an error if the element needs to be replaced.\n * @return {Element} The parent, in case it was added.\n * @private\n */\nfunction buildParentIfNecessary_(element) {\n\tif (!element || !element.parentNode) {\n\t\tconst parent = document.createElement('div');\n\t\tif (element) {\n\t\t\tappend(parent, element);\n\t\t}\n\t\treturn parent;\n\t}\n}\n\n/**\n * Calls incremental dom's patch function.\n * @param {!Component} component The component to patch.\n * @param {!Element} element The element the component should be patched on.\n * @param {boolean=} opt_outer Flag indicating if `patchOuter` should be used\n *     instead of `patch`.\n * @private\n */\nfunction callPatch_(component, element, opt_outer) {\n\tpatchingComponents_.push(component);\n\n\tconst data = getData(component);\n\tif (!data.render) {\n\t\t// Store reference to avoid binds on every patch.\n\t\tdata.render = render.bind(null, component);\n\t}\n\n\tconst patchFn = opt_outer ? IncrementalDOM.patchOuter : IncrementalDOM.patch;\n\tpatchFn(element, data.render);\n\n\tpatchingComponents_.pop();\n}\n\n/**\n * Gets the component that triggered the current patch operation.\n * @return {Component}\n */\nexport function getPatchingComponent() {\n\treturn patchingComponents_[patchingComponents_.length - 1];\n}\n\n/**\n * Patches the component with incremental dom function calls.\n * @param {!Component} component\n */\nexport function patch(component) {\n\tif (!tryPatchEmptyWithParent_(component)) {\n\t\tif (!tryPatchWithNoParent_(component)) {\n\t\t\tconst element = component.element;\n\t\t\tcallPatch_(component, element, true);\n\t\t}\n\t}\n}\n\n/**\n * Checks if the component has no content but was rendered from another\n * component. If so, we'll need to patch this parent to make sure that any new\n * content will be added in the right position.\n * @param {!Component} component\n * @return {?boolean} True if the patch happened. Nothing otherwise.\n * @private\n */\nfunction tryPatchEmptyWithParent_(component) {\n\tconst data = getData(component);\n\tif (!component.element && data.parent) {\n\t\tdata.parent.getRenderer().patch(data.parent);\n\t\treturn true;\n\t}\n}\n\n/**\n * Checks if the component's element exists and has a parent. If that's not the\n * case, a temporary parent will be created and passed to the `patch` function,\n * since incremental dom requires it. Once the patch is done the temporary\n * parent is removed and the component's content is reattached to the correct\n * final position.\n * @param {!Component} component\n * @return {?boolean} True if the patch happened. Nothing otherwise.\n * @private\n */\nfunction tryPatchWithNoParent_(component) {\n\tconst tempParent = buildParentIfNecessary_(component.element);\n\tif (tempParent) {\n\t\tcallPatch_(component, tempParent);\n\t\texitDocument(component.element);\n\t\tif (component.element && component.inDocument) {\n\t\t\tconst attach = component.getAttachData();\n\t\t\tcomponent.attachElement(attach.parent, attach.sibling);\n\t\t}\n\t\treturn true;\n\t}\n}\n"]}