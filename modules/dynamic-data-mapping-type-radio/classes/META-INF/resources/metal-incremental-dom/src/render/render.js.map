{"version":3,"sources":["render.js"],"names":["getComponentBeingRendered","isComponentTag_","render","renderChild","renderFunction","renderingComponents_","emptyChildren_","addElementClasses_","elementClasses","config","class","removeDuplicateClasses_","buildChildren_","children","length","cleanUpRender_","component","rootElementReached","element","informRendered","finishedRenderingComponent_","pop","generateKey_","key","data","getRenderer","generateKey","getChildComponents_","childComponents","getCurrentData","IncrementalDOM","currentElement","comp","obj","parentNode","get","icComponentsData","getRef_","owner","compatData","ownerRenderer","renderers","useKey","indexOf","RENDERER_NAME","ref","getSubComponent_","tagOrCtor","Ctor","getConstructor","match_","components","refs","type","currCount","prevComps","currComps","handleChildrenCaptured_","tree","props","tag","renderFromTag_","handleChildRender_","node","handleInterceptedAttributesCall_","name","value","handleInterceptedOpenCall_","handleSubComponentCall_","apply","arguments","handleRegularCall_","args","getDataManager","call","resetNodeData_","updateElementIfNotReached_","handleNodeRendered","inheritElementClasses_","parent","parentData","parentConfig","currentClasses","toUpperCase","isMatch_","constructor","isDisposed","startSkipUpdates","replaceNonInternal","stopSkipUpdates","prepareRender_","push","resetComponentsData_","attributes","elementOpen","classString","classes","all","split","used","i","join","renderIncDom","child","opt_owner","prototype","renderSubComponent_","renderer","fnOrCtor","opt_dataOrElement","opt_parent","isComponentCtor","fn","TempComponent","updateContext_","getInitialConfig","RENDERER","renderInsidePatch","wasRendered","renderComponent","has","context","childContext","getChildContext","mixin"],"mappings":"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","file":"render.js","sourcesContent":["'use strict';\n\nimport { applyAttribute, convertListenerNamesToFns } from './attributes';\nimport { buildConfigFromCall, buildCallFromConfig } from '../callArgs';\nimport { captureChildren, getOwner, isChildTag, renderChildTree } from '../children/children';\nimport { clearChanges } from '../changes';\nimport { domData } from 'metal-dom';\nimport { getData } from '../data';\nimport { getCompatibilityModeData, getUid, isDef, isDefAndNotNull, isFunction, isString, object } from 'metal';\nimport { disposeUnused, schedule } from '../cleanup/unused';\nimport { getOriginalFn, startInterception, stopInterception } from '../incremental-dom-aop';\nimport { Component, ComponentRegistry } from 'metal-component';\n\nconst renderingComponents_ = [];\nconst emptyChildren_ = [];\n\n/**\n * Adds the given css classes to the specified arguments for an incremental\n * dom call, merging with the existing value if there is one.\n * @param {string} elementClasses\n * @param {!Object} config\n * @private\n */\nfunction addElementClasses_(elementClasses, config) {\n\tif (config.class) {\n\t\tconfig.class += ` ${elementClasses}`;\n\t\tconfig.class = removeDuplicateClasses_(config.class);\n\t} else {\n\t\tconfig.class = elementClasses;\n\t}\n}\n\n/**\n * Builds the \"children\" array to be passed to the current component.\n * @param {!Array<!Object>} children\n * @return {!Array<!Object>}\n * @private\n */\nfunction buildChildren_(children) {\n\treturn children.length === 0 ? emptyChildren_ : children;\n}\n\n/**\n * Finishes the render operation, doing some cleaups.\n * @param {!Component} component\n * @private\n */\nfunction cleanUpRender_(component) {\n\tstopInterception();\n\tif (!getData(component).rootElementReached) {\n\t\tcomponent.element = null;\n\t}\n\tcomponent.informRendered();\n\tfinishedRenderingComponent_();\n}\n\n/**\n * Removes the most recent component from the queue of rendering components.\n * @private\n */\nfunction finishedRenderingComponent_() {\n\trenderingComponents_.pop();\n\tif (renderingComponents_.length === 0) {\n\t\tdisposeUnused();\n\t}\n}\n\n/**\n * Generates a key for the next element to be rendered.\n * @param {!Component} component\n * @param {?string} key The key originally passed to the element.\n * @return {?string}\n * @private\n */\nfunction generateKey_(component, key) {\n\tconst data = getData(component);\n\tif (!data.rootElementReached && data.config.key) {\n\t\tkey = data.config.key;\n\t}\n\treturn component.getRenderer().generateKey(component, key);\n}\n\n/**\n * Gets the child components stored in the given object.\n * @param {!Object} data\n * @return {!Array<!Component>}\n * @private\n */\nfunction getChildComponents_(data) {\n\tdata.childComponents = data.childComponents || [];\n\treturn data.childComponents;\n}\n\n/**\n * Gets the component being currently rendered.\n * @return {Component}\n */\nexport function getComponentBeingRendered() {\n\treturn renderingComponents_[renderingComponents_.length - 1];\n}\n\n/**\n * Gets the data object that should be currently used. This object will either\n * come from the current element being rendered by incremental dom or from\n * the component instance being rendered (only when the current element is the\n * component's direct parent).\n * @return {!Object}\n * @private\n */\nfunction getCurrentData() {\n\tconst element = IncrementalDOM.currentElement();\n\tconst comp = getComponentBeingRendered();\n\tlet obj = getData(comp);\n\tif (obj.rootElementReached && element !== comp.element.parentNode) {\n\t\tobj = domData.get(element);\n\t}\n\tobj.icComponentsData = obj.icComponentsData || {};\n\treturn obj.icComponentsData;\n}\n\n/**\n * Returns the \"ref\" to be used for a component. Uses \"key\" as \"ref\" when\n * compatibility mode is on for the current renderer.\n * @param {!Component} owner\n * @param {!Object} config\n * @return {?string}\n * @private\n */\nfunction getRef_(owner, config) {\n\tconst compatData = getCompatibilityModeData();\n\tif (compatData) {\n\t\tconst ownerRenderer = owner.getRenderer();\n\t\tconst renderers = compatData.renderers;\n\t\tconst useKey = !renderers ||\n\t\t\trenderers.indexOf(ownerRenderer) !== -1 ||\n\t\t\trenderers.indexOf(ownerRenderer.RENDERER_NAME) !== -1;\n\t\tif (useKey && config.key && !config.ref) {\n\t\t\treturn config.key;\n\t\t}\n\t}\n\treturn config.ref;\n}\n\n/**\n * Gets the sub component referenced by the given tag and config data,\n * creating it if it doesn't yet exist.\n * @param {string|!Function} tagOrCtor The tag name.\n * @param {!Object} config The config object for the sub component.\n * @param {!Component} owner\n * @return {!Component} The sub component.\n * @protected\n */\nfunction getSubComponent_(tagOrCtor, config, owner) {\n\tlet Ctor = tagOrCtor;\n\tif (isString(Ctor)) {\n\t\tCtor = ComponentRegistry.getConstructor(tagOrCtor);\n\t}\n\n\tconst ref = getRef_(owner, config);\n\tlet comp;\n\tif (isDef(ref)) {\n\t\tcomp = match_(owner.components[ref], Ctor, config, owner);\n\t\towner.components[ref] = comp;\n\t\towner.refs[ref] = comp;\n\t} else {\n\t\tconst data = getCurrentData();\n\t\tlet key = config.key;\n\t\tif (!isDef(key)) {\n\t\t\tconst type = getUid(Ctor, true);\n\t\t\tdata.currCount = data.currCount || {};\n\t\t\tdata.currCount[type] = data.currCount[type] || 0;\n\t\t\tkey = `__METAL_IC__${type}_${data.currCount[type]++}`;\n\t\t}\n\t\tcomp = match_(data.prevComps ? data.prevComps[key] : null, Ctor, config, owner);\n\t\tdata.currComps = data.currComps || {};\n\t\tdata.currComps[key] = comp;\n\t}\n\n\treturn comp;\n}\n\n/**\n * Handles the event of children having finished being captured.\n * @param {!Object} tree The captured children in tree format.\n * @private\n */\nfunction handleChildrenCaptured_(tree, {props, tag}) {\n\tprops.children = buildChildren_(tree.props.children);\n\treturn renderFromTag_(tag, props);\n}\n\n/**\n * Handles a child being rendered via `IncrementalDomChildren.render`. Skips\n * component nodes so that they can be rendered the correct way without\n * having to recapture both them and their children via incremental dom.\n * @param {!Object} node\n * @return {boolean}\n * @private\n */\nfunction handleChildRender_(node) {\n\tif (node.tag && isComponentTag_(node.tag)) {\n\t\tnode.props.children = buildChildren_(node.props.children);\n\t\trenderFromTag_(node.tag, node.props, getOwner(node));\n\t\treturn true;\n\t}\n}\n\n/**\n * Handles an intercepted call to the attributes default handler from\n * incremental dom.\n * @param {!Element} element\n * @param {string} name\n * @param {*} value\n * @private\n */\nfunction handleInterceptedAttributesCall_(element, name, value) {\n\tapplyAttribute(getComponentBeingRendered(), element, name, value);\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom.\n * @param {string} tag\n * @private\n */\nfunction handleInterceptedOpenCall_(tag) {\n\tif (isComponentTag_(tag)) {\n\t\treturn handleSubComponentCall_.apply(null, arguments);\n\t} else {\n\t\treturn handleRegularCall_.apply(null, arguments);\n\t}\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom, done for a regular element. Among other things, adds any inline\n * listeners found on the first render and makes sure that component root\n * elements are always reused.\n * @param {!Component} owner\n * @param {!Array} args\n * @return {!Element} The rendered element.\n * @private\n */\nfunction handleRegularCall_(...args) {\n\tconst config = buildConfigFromCall(args);\n\tlet tag = args[0];\n\n\tconst comp = getComponentBeingRendered();\n\tlet owner = comp;\n\tif (isChildTag(tag)) {\n\t\towner = tag.owner;\n\t\ttag = tag.tag;\n\t}\n\tconfig.key = generateKey_(comp, config.key);\n\n\tif (!getData(comp).rootElementReached) {\n\t\tconst elementClasses = comp.getDataManager().get(comp, 'elementClasses');\n\t\tif (elementClasses) {\n\t\t\taddElementClasses_(elementClasses, config);\n\t\t}\n\t}\n\tconvertListenerNamesToFns(comp, config);\n\n\tconst call = buildCallFromConfig(tag, config);\n\tconst node = getOriginalFn('elementOpen').apply(null, call);\n\tresetNodeData_(node);\n\tupdateElementIfNotReached_(comp, node);\n\n\tif (isDefAndNotNull(config.ref)) {\n\t\towner.refs[config.ref] = node;\n\t}\n\towner.getRenderer().handleNodeRendered(node);\n\n\treturn node;\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom, done for a sub component element. Creates and updates the appropriate\n * sub component.\n * @private\n */\nfunction handleSubComponentCall_(...args) {\n\tcaptureChildren(getComponentBeingRendered(), handleChildrenCaptured_, {\n\t\tprops: buildConfigFromCall(args),\n\t\ttag: args[0]\n\t});\n}\n\n/**\n * Passes down elementClasses to a child component if the parent component\n * returns another component at the top level (HOC).\n * @param {*} parent The parent component\n * @param {*} config The config of the subcomponent\n */\nfunction inheritElementClasses_(parent, config) {\n\tconst parentData = getData(parent);\n\tconst parentConfig = parentData.config;\n\n\tif (!parentData.rootElementReached && parentConfig && isString(parentConfig.elementClasses)) {\n\t\tlet currentClasses = '';\n\t\tif (isString(config.elementClasses)) {\n\t\t\tcurrentClasses = `${config.elementClasses} `;\n\t\t}\n\n\t\tconfig.elementClasses = currentClasses + parentConfig.elementClasses;\n\t}\n}\n\n/**\n * Checks if the given tag represents a metal component.\n * @param {string} tag\n * @return {boolean}\n * @private\n */\nexport function isComponentTag_(tag) {\n\treturn isFunction(tag) || (isString(tag) && tag[0] === tag[0].toUpperCase());\n}\n\n/**\n * Checks if the given component can be a match for a constructor.\n * @param {!Component} comp\n * @param {!function()} Ctor\n * @param {!Component} owner\n * @return {boolean}\n * @private\n */\nfunction isMatch_(comp, Ctor, owner) {\n\tif (!comp || comp.constructor !== Ctor || comp.isDisposed()) {\n\t\treturn false;\n\t}\n\treturn getData(comp).owner === owner;\n}\n\n/**\n * Returns the given component if it matches the specified constructor\n * function. Otherwise, returns a new instance of the given constructor. On\n * both cases the component's state and config will be updated.\n * @param {Component} comp\n * @param {!function()} Ctor\n * @param {!Object} config\n * @param {!Component} owner\n * @return {!Component}\n * @private\n */\nfunction match_(comp, Ctor, config, owner) {\n\tif (isMatch_(comp, Ctor, owner)) {\n\t\tcomp.startSkipUpdates();\n\t\tcomp.getDataManager().replaceNonInternal(comp, config);\n\t\tcomp.stopSkipUpdates();\n\t} else {\n\t\tcomp = new Ctor(config, false);\n\t}\n\tgetData(comp).config = config;\n\treturn comp;\n}\n\n/**\n * Prepares the render operation, resetting the component's data and starting\n * the incremental dom interception.\n * @param {!Component} component\n * @private\n */\nfunction prepareRender_(component) {\n\trenderingComponents_.push(component);\n\n\tconst data = getData(component);\n\tresetComponentsData_(data.icComponentsData);\n\tclearChanges(data);\n\tdata.rootElementReached = false;\n\tcomponent.refs = {};\n\n\tif (data.childComponents) {\n\t\tschedule(data.childComponents);\n\t\tdata.childComponents = null;\n\t}\n\n\tstartInterception({\n\t\tattributes: handleInterceptedAttributesCall_,\n\t\telementOpen: handleInterceptedOpenCall_\n\t});\n}\n\n/**\n * Removes duplicate css classes from the given string.\n * @param {string} classString\n * @return {string}\n * @private\n */\nfunction removeDuplicateClasses_(classString) {\n\tconst classes = [];\n\tconst all = classString.split(/\\s+/);\n\tconst used = {};\n\tfor (let i = 0; i < all.length; i++) {\n\t\tif (!used[all[i]]) {\n\t\t\tused[all[i]] = true;\n\t\t\tclasses.push(all[i]);\n\t\t}\n\t}\n\treturn classes.join(' ');\n}\n\n/**\n * Renders the component with incremental dom function calls. This assumes that\n * an incremental dom `patch` is already running, and that this function has\n * been called inside it.\n * @param {!Component} component\n */\nexport function render(component) {\n\tprepareRender_(component);\n\tcomponent.getRenderer().renderIncDom(component);\n\tcleanUpRender_(component);\n}\n\n/**\n * Renders the given child node.\n * @param {!Object} child\n */\nexport function renderChild(child) {\n\trenderChildTree(child, handleChildRender_);\n}\n\n/**\n * Renders the contents for the given tag.\n * @param {!function()|string} tag\n * @param {!Object} config\n * @param {Component=} opt_owner\n * @private\n */\nfunction renderFromTag_(tag, config, opt_owner) {\n\tif (isString(tag) || tag.prototype.getRenderer) {\n\t\tconst comp = renderSubComponent_(tag, config, opt_owner);\n\t\tupdateElementIfNotReached_(getComponentBeingRendered(), comp.element);\n\t\treturn comp.element;\n\t} else {\n\t\treturn tag(config);\n\t}\n}\n\n/**\n * Creates and renders the given function, which can either be a simple\n * incremental dom function or a component constructor.\n * @param {!IncrementalDomRenderer} renderer\n * @param {!function()} fnOrCtor Either a simple incremental dom function or a\n *     component constructor.\n * @param {Object|Element=} opt_dataOrElement Optional config data for the\n *     function or parent for the rendered content.\n * @param {Element=} opt_parent Optional parent for the rendered content.\n * @return {!Component} The rendered component's instance.\n */\nexport function renderFunction(renderer, fnOrCtor, opt_dataOrElement, opt_parent) {\n\tif (!Component.isComponentCtor(fnOrCtor)) {\n\t\tconst fn = fnOrCtor;\n\t\tclass TempComponent extends Component {\n\t\t\tcreated() {\n\t\t\t\tconst parent = getComponentBeingRendered();\n\t\t\t\tif (parent) {\n\t\t\t\t\tupdateContext_(this, parent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trender() {\n\t\t\t\tfn(this.getInitialConfig());\n\t\t\t}\n\t\t}\n\t\tTempComponent.RENDERER = renderer;\n\t\tfnOrCtor = TempComponent;\n\t}\n\treturn Component.render(fnOrCtor, opt_dataOrElement, opt_parent);\n}\n\n/**\n * This updates the sub component that is represented by the given data.\n * The sub component is created, added to its parent and rendered. If it\n * had already been rendered before though, it will only have its state\n * updated instead.\n * @param {string|!function()} tagOrCtor The tag name or constructor function.\n * @param {!Object} config The config object for the sub component.\n * @param {ComponentRenderer=} opt_owner\n * @return {!Component} The updated sub component.\n * @private\n */\nfunction renderSubComponent_(tagOrCtor, config, opt_owner) {\n\tconst parent = getComponentBeingRendered();\n\tconst owner = opt_owner || parent;\n\n\tinheritElementClasses_(parent, config)\n\n\tconst comp = getSubComponent_(tagOrCtor, config, owner);\n\tupdateContext_(comp, parent);\n\n\tconst data = getData(comp);\n\tdata.parent = parent;\n\tdata.owner = owner;\n\n\tconst parentData = getData(parent);\n\tgetChildComponents_(parentData).push(comp);\n\tif (!config.key && !parentData.rootElementReached) {\n\t\tconfig.key = parentData.config.key;\n\t}\n\n\tcomp.getRenderer().renderInsidePatch(comp);\n\tif (!comp.wasRendered) {\n\t\tcomp.renderComponent();\n\t}\n\treturn comp;\n}\n\n/**\n * Resets the given incremental dom data object, preparing it for the next pass.\n * @param {Object} data\n * @private\n */\nfunction resetComponentsData_(data) {\n\tif (data) {\n\t\tdata.prevComps = data.currComps;\n\t\tdata.currComps = null;\n\t\tdata.currCount = null;\n\t}\n}\n/**\n * Resets all data stored in the given node.\n * @param {!Element} node\n * @private\n */\nfunction resetNodeData_(node) {\n\tif (domData.has(node)) {\n\t\tresetComponentsData_(domData.get(node).icComponentsData);\n\t}\n}\n\n/**\n * Updates the given component's context according to the data from the\n * component that is currently being rendered.\n * @param {!Component} comp\n * @protected\n */\nfunction updateContext_(comp, parent) {\n\tconst context = comp.context;\n\tconst childContext = parent.getChildContext ? parent.getChildContext() : null;\n\tobject.mixin(context, parent.context, childContext);\n\tcomp.context = context;\n}\n\n/**\n * Updates this renderer's component's element with the given values, unless\n * it has already been reached by an earlier call.\n * @param {!Component} component\n * @param {!Element} node\n * @private\n */\nfunction updateElementIfNotReached_(component, node) {\n\tconst data = getData(component);\n\tif (!data.rootElementReached) {\n\t\tdata.rootElementReached = true;\n\t\tif (component.element !== node) {\n\t\t\tcomponent.element = node;\n\t\t}\n\t}\n}\n"]}