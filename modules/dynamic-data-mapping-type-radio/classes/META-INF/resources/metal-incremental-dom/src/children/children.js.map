{"version":3,"sources":["children.js"],"names":["captureChildren","isChildTag","getOwner","renderChildTree","CHILD_OWNER","component","callback","data","owner_","callback_","callbackData_","tree_","props","children","config","currentParent_","isCapturing_","elementClose","handleInterceptedCloseCall_","elementOpen","handleInterceptedOpenCall_","text","handleInterceptedTextCall_","tag","node","tree","opt_skipNode","addChildToTree","call","args","IncrementalDOM","apply","owner","i","length","addChildCallToTree_","opt_isText","child","parent","push"],"mappings":";AAAA;;;;;;SAoBgBA,e,GAAAA,e;SAwBAC,U,GAAAA,U;SASAC,Q,GAAAA,Q;SAWAC,e,GAAAA,e;;;;;;;;;;;;;;;;;AA1DhB;;;;;AAKO,KAAMC,oCAAc,mBAApB;;AAEP;;;;;;;AAOO,UAASJ,eAAT,CAAyBK,SAAzB,EAAoCC,QAApC,EAA8CC,IAA9C,EAAoD;AAC1DC,WAASH,SAAT;AACAI,cAAYH,QAAZ;AACAI,kBAAgBH,IAAhB;AACAI,UAAQ;AACPC,UAAO;AACNC,cAAU;AADJ;AADA,GAAR;AAKAF,QAAMG,MAAN,GAAeH,MAAMC,KAArB;AACAG,mBAAiBJ,KAAjB;AACAK,iBAAe,IAAf;AACA,4CAAkB;AACjBC,iBAAcC,2BADG;AAEjBC,gBAAaC,0BAFI;AAGjBC,SAAMC;AAHW,GAAlB;AAKA;;AAED;;;;;AAKO,UAASrB,UAAT,CAAoBsB,GAApB,EAAyB;AAC/B,SAAO,kBAAMA,IAAIA,GAAV,CAAP;AACA;;AAED;;;;;AAKO,UAASrB,QAAT,CAAkBsB,IAAlB,EAAwB;AAC9B,SAAOA,KAAKpB,WAAL,CAAP;AACA;;AAED;;;;;;;AAOO,UAASD,eAAT,CAAyBsB,IAAzB,EAA+BC,YAA/B,EAA6C;AACnD,MAAIV,YAAJ,EAAkB;AACjB;AACAW,kBAAeF,IAAf;AACA;AACA;;AAED,MAAIC,gBAAgBA,aAAaE,IAAb,CAAkB,IAAlB,EAAwBH,IAAxB,CAApB,EAAmD;AAClD;AACA;;AAED,MAAI,kBAAMA,KAAKJ,IAAX,CAAJ,EAAsB;AACrB,OAAIQ,OAAOJ,KAAKI,IAAL,GAAYJ,KAAKI,IAAjB,GAAwB,EAAnC;AACAA,QAAK,CAAL,IAAUJ,KAAKJ,IAAf;AACAS,kBAAeT,IAAf,CAAoBU,KAApB,CAA0B,IAA1B,EAAgCF,IAAhC;AACA,GAJD,MAIO;AACN,OAAIA,QAAO,mCAAoBJ,KAAKF,GAAzB,EAA8BE,KAAKb,KAAnC,CAAX;AACAiB,SAAK,CAAL,IAAU;AACTN,SAAKM,MAAK,CAAL,CADI;AAETG,WAAO9B,SAASuB,IAAT;AAFE,IAAV;AAIAK,kBAAeX,WAAf,CAA2BY,KAA3B,CAAiC,IAAjC,EAAuCF,KAAvC;AACA,OAAIJ,KAAKb,KAAL,CAAWC,QAAf,EAAyB;AACxB,SAAK,IAAIoB,IAAI,CAAb,EAAgBA,IAAIR,KAAKb,KAAL,CAAWC,QAAX,CAAoBqB,MAAxC,EAAgDD,GAAhD,EAAqD;AACpD9B,qBAAgBsB,KAAKb,KAAL,CAAWC,QAAX,CAAoBoB,CAApB,CAAhB,EAAwCP,YAAxC;AACA;AACD;AACDI,kBAAeb,YAAf,CAA4BQ,KAAKF,GAAjC;AACA;AACD;;AAED,KAAIb,sBAAJ;AACA,KAAID,kBAAJ;AACA,KAAIM,uBAAJ;AACA,KAAIC,eAAe,KAAnB;AACA,KAAIR,eAAJ;AACA,KAAIG,cAAJ;;AAEA;;;;;;;AAOA,UAASwB,mBAAT,CAA6BN,IAA7B,EAAmCO,UAAnC,EAA+C;AAC9C,MAAMC;AACLC,WAAQvB;AADH,KAEJX,WAFI,EAEUI,MAFV,CAAN;;AAKA,MAAI4B,UAAJ,EAAgB;AACfC,SAAMhB,IAAN,GAAaQ,KAAK,CAAL,CAAb;AACA,OAAIA,KAAKK,MAAL,GAAc,CAAlB,EAAqB;AACpBG,UAAMR,IAAN,GAAaA,IAAb;AACA;AACD,GALD,MAKO;AACNQ,SAAMd,GAAN,GAAYM,KAAK,CAAL,CAAZ;AACAQ,SAAMzB,KAAN,GAAc,mCAAoBiB,IAApB,CAAd;AACAQ,SAAMzB,KAAN,CAAYC,QAAZ,GAAuB,EAAvB;AACAwB,SAAMvB,MAAN,GAAeuB,MAAMzB,KAArB;AACA;;AAEDe,iBAAeU,KAAf;AACA,SAAOA,KAAP;AACA;;AAED,UAASV,cAAT,CAAwBU,KAAxB,EAA+B;AAC9BtB,iBAAeH,KAAf,CAAqBC,QAArB,CAA8B0B,IAA9B,CAAmCF,KAAnC;AACA;;AAED;;;;;AAKA,UAASnB,2BAAT,GAAuC;AACtC,MAAIH,mBAAmBJ,KAAvB,EAA8B;AAC7B;AACAK,kBAAe,KAAf;AACA,OAAMQ,OAAOf,UAAUmB,IAAV,CAAepB,MAAf,EAAuBG,KAAvB,EAA8BD,aAA9B,CAAb;AACAD,eAAY,IAAZ;AACAC,mBAAgB,IAAhB;AACAK,oBAAiB,IAAjB;AACAP,YAAS,IAAT;AACAG,WAAQ,IAAR;AACA,UAAOa,IAAP;AACA,GAVD,MAUO;AACNT,oBAAiBA,eAAeuB,MAAhC;AACA,UAAO,IAAP;AACA;AACD;;AAED;;;;;;AAMA,UAASlB,0BAAT,GAA6C;AAAA,oCAANS,IAAM;AAANA,OAAM;AAAA;;AAC5Cd,mBAAiBoB,oBAAoBN,IAApB,CAAjB;AACA;;AAED;;;;;AAKA,UAASP,0BAAT,GAA6C;AAAA,qCAANO,IAAM;AAANA,OAAM;AAAA;;AAC5CM,sBAAoBN,IAApB,EAA0B,IAA1B;AACA","file":"children.js","sourcesContent":["'use strict';\n\nimport { buildCallFromConfig, buildConfigFromCall } from '../callArgs';\nimport { isDef } from 'metal';\nimport { startInterception, stopInterception } from '../incremental-dom-aop';\n\n/**\n * Property identifying a specific object as a Metal.js child node, and\n * pointing to the component instance that created it.\n * @type {string}\n */\nexport const CHILD_OWNER = '__metalChildOwner';\n\n/**\n * Captures all child elements from incremental dom calls.\n * @param {!Component} component The component that is capturing children.\n * @param {!function()} callback Function to be called when children have all\n *     been captured.\n * @param {Object} data Data to pass to the callback function when calling it.\n */\nexport function captureChildren(component, callback, data) {\n\towner_ = component;\n\tcallback_ = callback;\n\tcallbackData_ = data;\n\ttree_ = {\n\t\tprops: {\n\t\t\tchildren: []\n\t\t}\n\t};\n\ttree_.config = tree_.props;\n\tcurrentParent_ = tree_;\n\tisCapturing_ = true;\n\tstartInterception({\n\t\telementClose: handleInterceptedCloseCall_,\n\t\telementOpen: handleInterceptedOpenCall_,\n\t\ttext: handleInterceptedTextCall_\n\t});\n}\n\n/**\n * Checks if the given tag was built from a component's children.\n * @param {*} tag\n * @return {boolean}\n */\nexport function isChildTag(tag) {\n\treturn isDef(tag.tag);\n}\n\n/**\n * Gets the node's original owner.\n * @param {!Object} node\n * @return {Component}\n */\nexport function getOwner(node) {\n\treturn node[CHILD_OWNER];\n}\n\n/**\n * Renders a children tree through incremental dom.\n * @param {!{args: Array, children: !Array, isText: ?boolean}}\n * @param {function()=} opt_skipNode Optional function that is called for\n *     each node to be rendered. If it returns true, the node will be skipped.\n * @protected\n */\nexport function renderChildTree(tree, opt_skipNode) {\n\tif (isCapturing_) {\n\t\t// If capturing, just add the node directly to the captured tree.\n\t\taddChildToTree(tree);\n\t\treturn;\n\t}\n\n\tif (opt_skipNode && opt_skipNode.call(null, tree)) {\n\t\treturn;\n\t}\n\n\tif (isDef(tree.text)) {\n\t\tlet args = tree.args ? tree.args : [];\n\t\targs[0] = tree.text;\n\t\tIncrementalDOM.text.apply(null, args);\n\t} else {\n\t\tlet args = buildCallFromConfig(tree.tag, tree.props);\n\t\targs[0] = {\n\t\t\ttag: args[0],\n\t\t\towner: getOwner(tree)\n\t\t};\n\t\tIncrementalDOM.elementOpen.apply(null, args);\n\t\tif (tree.props.children) {\n\t\t\tfor (let i = 0; i < tree.props.children.length; i++) {\n\t\t\t\trenderChildTree(tree.props.children[i], opt_skipNode);\n\t\t\t}\n\t\t}\n\t\tIncrementalDOM.elementClose(tree.tag);\n\t}\n}\n\nlet callbackData_;\nlet callback_;\nlet currentParent_;\nlet isCapturing_ = false;\nlet owner_;\nlet tree_;\n\n/**\n * Adds a child element to the tree.\n * @param {!Array} args The arguments passed to the incremental dom call.\n * @param {boolean=} opt_isText Optional flag indicating if the child is a\n *     text element.\n * @protected\n */\nfunction addChildCallToTree_(args, opt_isText) {\n\tconst child = {\n\t\tparent: currentParent_,\n\t\t[CHILD_OWNER]: owner_\n\t};\n\n\tif (opt_isText) {\n\t\tchild.text = args[0];\n\t\tif (args.length > 1) {\n\t\t\tchild.args = args;\n\t\t}\n\t} else {\n\t\tchild.tag = args[0];\n\t\tchild.props = buildConfigFromCall(args);\n\t\tchild.props.children = [];\n\t\tchild.config = child.props;\n\t}\n\n\taddChildToTree(child);\n\treturn child;\n}\n\nfunction addChildToTree(child) {\n\tcurrentParent_.props.children.push(child);\n}\n\n/**\n * Handles an intercepted call to the `elementClose` function from incremental\n * dom.\n * @protected\n */\nfunction handleInterceptedCloseCall_() {\n\tif (currentParent_ === tree_) {\n\t\tstopInterception();\n\t\tisCapturing_ = false;\n\t\tconst node = callback_.call(owner_, tree_, callbackData_);\n\t\tcallback_ = null;\n\t\tcallbackData_ = null;\n\t\tcurrentParent_ = null;\n\t\towner_ = null;\n\t\ttree_ = null;\n\t\treturn node;\n\t} else {\n\t\tcurrentParent_ = currentParent_.parent;\n\t\treturn true;\n\t}\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom.\n * @param {!function()} originalFn The original function before interception.\n * @protected\n */\nfunction handleInterceptedOpenCall_(...args) {\n\tcurrentParent_ = addChildCallToTree_(args);\n}\n\n/**\n * Handles an intercepted call to the `text` function from incremental dom.\n * @param {!function()} originalFn The original function before interception.\n * @protected\n */\nfunction handleInterceptedTextCall_(...args) {\n\taddChildCallToTree_(args, true);\n}\n"]}