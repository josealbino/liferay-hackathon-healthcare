{"version":3,"sources":["validators.js"],"names":["ERROR_ARRAY_OF_TYPE","ERROR_OBJECT_OF_TYPE","ERROR_ONE_OF","ERROR_ONE_OF_TYPE","ERROR_SHAPE_OF","validators","any","array","buildTypeValidator","bool","func","number","object","string","arrayOf","validator","maybe","value","name","context","result","isInvalid","validateArrayItems","instanceOf","expectedClass","msg","composeError","objectOf","key","oneOf","arrayOfValues","indexOf","oneOfType","arrayOfTypeValidators","i","length","shapeOf","shape","required","config","expectedType","validatorFn","validateType","bind","error","compName","constructor","renderer","getRenderer","parent","getParent","parentName","location","Error","getType","Array","isArray","typeValidator","type"],"mappings":"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","file":"validators.js","sourcesContent":["'use strict';\n\nimport { getFunctionName, isDefAndNotNull } from 'metal';\n\nconst ERROR_ARRAY_OF_TYPE = 'Expected an array of single type.';\nconst ERROR_OBJECT_OF_TYPE = 'Expected object of one type.';\nconst ERROR_ONE_OF = 'Expected one of given values.';\nconst ERROR_ONE_OF_TYPE = 'Expected one of given types.';\nconst ERROR_SHAPE_OF = 'Expected object with a specific shape.';\n\n/**\n * Provides access to various type validators that will return an\n * instance of Error when validation fails. Note that all type validators\n * will also accept null or undefined values. To not accept these you should\n * instead make your state property required.\n */\nconst validators = {\n\tany: () => () => true,\n\tarray: buildTypeValidator('array'),\n\tbool: buildTypeValidator('boolean'),\n\tfunc: buildTypeValidator('function'),\n\tnumber: buildTypeValidator('number'),\n\tobject: buildTypeValidator('object'),\n\tstring: buildTypeValidator('string'),\n\n\t/**\n\t * Creates a validator that checks that the value it receives is an array\n\t * of items, and that all of the items pass the given validator.\n\t * @param {!function()} validator Validator to check each item against.\n\t * @return {!function()}\n\t */\n\tarrayOf: function(validator) {\n\t\treturn maybe((value, name, context) => {\n\t\t\tconst result = validators.array(value, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn validateArrayItems(validator, value, name, context);\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks if a value is an instance of a given class.\n\t * @param {!function()} expectedClass Class to check value against.\n\t * @return {!function()}\n\t */\n\tinstanceOf: function(expectedClass) {\n\t\treturn maybe((value, name, context) => {\n\t\t\tif (value instanceof expectedClass) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst msg = `Expected instance of ${expectedClass}`;\n\t\t\treturn composeError(msg, name, context);\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks that the value it receives is an object,\n\t * and that all values within that object pass the given validator.\n\t * @param {!function()} validator Validator to check each object value against.\n\t * @return {!function()}\n\t */\n\tobjectOf: function(validator) {\n\t\treturn maybe((value, name, context) => {\n\t\t\tfor (let key in value) {\n\t\t\t\tif (isInvalid(validator(value[key]))) {\n\t\t\t\t\treturn composeError(ERROR_OBJECT_OF_TYPE, name, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks if the received value matches one of the\n\t * given values.\n\t * @param {!Array} arrayOfValues Array of values to check equality against.\n\t * @return {!function()}\n\t */\n\toneOf: function(arrayOfValues) {\n\t\treturn maybe((value, name, context) => {\n\t\t\tconst result = validators.array(arrayOfValues, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn arrayOfValues.indexOf(value) === -1 ?\n\t\t\t\tcomposeError(ERROR_ONE_OF, name, context) :\n\t\t\t\ttrue;\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks if the received value matches one of the\n\t * given types.\n\t * @param {!Array} arrayOfTypeValidators Array of validators to check value\n\t *     against.\n\t * @return {!function()}\n\t */\n\toneOfType: function(arrayOfTypeValidators) {\n\t\treturn maybe((value, name, context) => {\n\t\t\tconst result = validators.array(arrayOfTypeValidators, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < arrayOfTypeValidators.length; i++) {\n\t\t\t\tif (!isInvalid(arrayOfTypeValidators[i](value, name, context))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn composeError(ERROR_ONE_OF_TYPE, name, context);\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks if the received value is an object, and\n\t * that its contents match the given shape.\n\t * @param {!Object} shape An object containing validators for each key.\n\t * @return {!function()}\n\t */\n\tshapeOf: function(shape) {\n\t\treturn maybe((value, name, context) => {\n\t\t\tconst result = validators.object(shape, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfor (let key in shape) {\n\t\t\t\tlet validator = shape[key];\n\t\t\t\tlet required = false;\n\t\t\t\tif (validator.config) {\n\t\t\t\t\trequired = validator.config.required;\n\t\t\t\t\tvalidator = validator.config.validator;\n\t\t\t\t}\n\t\t\t\tif ((required && !isDefAndNotNull(value[key])) ||\n\t\t\t\t\tisInvalid(validator(value[key]))) {\n\t\t\t\t\treturn composeError(ERROR_SHAPE_OF, name, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n};\n\n/**\n * Creates a validator that checks against a specific primitive type.\n * @param {string} expectedType Type to check against.\n * @return {!function()} Function that runs the validator if called with\n *     arguments, or just returns it otherwise. This means that when using a\n *     type validator in `State` it may be just passed directly (like\n *     `validators.bool`), or called with no args (like `validators.bool()`).\n *     That's done to allow all validators to be used consistently, since some\n *     (like `arrayOf`) always require that you call the function before\n *     receiving the actual validator. Type validators don't need the call, but\n *     work if it's made anyway.\n */\nfunction buildTypeValidator(expectedType) {\n\tconst validatorFn = maybe(validateType.bind(null, expectedType));\n\treturn (...args) => {\n\t\tif (args.length === 0) {\n\t\t\treturn validatorFn;\n\t\t} else {\n\t\t\treturn validatorFn(...args);\n\t\t}\n\t};\n}\n\n/**\n * Composes a warning a warning message.\n * @param {string} error Error message to display to console.\n * @param {?string} name Name of state property that is giving the error.\n * @param {Object} context The property's owner.\n * @return {!Error}\n */\nfunction composeError(error, name, context) {\n\tconst compName = context ? getFunctionName(context.constructor) : null;\n\tconst renderer = context && context.getRenderer && context.getRenderer();\n\tconst parent = renderer && renderer.getParent && renderer.getParent();\n\tconst parentName = parent ? getFunctionName(parent.constructor) : null;\n\tconst location = parentName ? `Check render method of '${parentName}'.` : '';\n\treturn new Error(\n\t\t`Warning: Invalid state passed to '${name}'. ` +\n\t\t`${error} Passed to '${compName}'. ${location}`\n\t);\n}\n\n/**\n * Returns the type of the given value.\n * @param {*} value Any value.\n * @return {string} Type of value.\n */\nfunction getType(value) {\n\treturn Array.isArray(value) ? 'array' : typeof value;\n}\n\n/**\n * Checks if the given validator result says that the value is invalid.\n * @param {boolean|!Error} result\n * @return {boolean}\n */\nfunction isInvalid(result) {\n\treturn result instanceof Error;\n}\n\n/**\n * Wraps the given validator so that it also accepts null/undefined values.\n *   a validator that checks a value against a single type, null, or\n * undefined.\n * @param {!function()} typeValidator Validator to wrap.\n * @return {!function()} Wrapped validator.\n */\nfunction maybe(typeValidator) {\n\treturn (value, name, context) => {\n\t\treturn isDefAndNotNull(value) ? typeValidator(value, name, context) : true;\n\t};\n}\n\n\n/**\n * Checks if all the items of the given array pass the given validator.\n * @param {!function()} validator\n * @param {*} value The array to validate items for.\n * @param {string} name The name of the array property being checked.\n * @param {!Object} context Owner of the array property being checked.\n * @return {!Error|boolean} `true` if the type matches, or an error otherwise.\n */\nfunction validateArrayItems(validator, value, name, context) {\n\tfor (let i = 0; i < value.length; i++) {\n\t\tif (isInvalid(validator(value[i], name, context))) {\n\t\t\treturn composeError(ERROR_ARRAY_OF_TYPE, name, context);\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Checks if the given value matches the expected type.\n * @param {string} expectedType String representing the expected type.\n * @param {*} value The value to match the type of.\n * @param {string} name The name of the property being checked.\n * @param {!Object} context Owner of the property being checked.\n * @return {!Error|boolean} `true` if the type matches, or an error otherwise.\n */\nfunction validateType(expectedType, value, name, context) {\n\tconst type = getType(value);\n\tif (type !== expectedType) {\n\t\tconst msg = `Expected type '${expectedType}', but received type '${type}'.`;\n\t\treturn composeError(msg, name, context);\n\t}\n\treturn true;\n}\n\nexport default validators;\n"]}