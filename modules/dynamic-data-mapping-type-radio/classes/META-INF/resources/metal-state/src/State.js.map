{"version":3,"sources":["State.js"],"names":["State","opt_config","opt_obj","opt_context","context_","keysBlacklist_","obj_","eventData_","scheduledBatchData_","stateInfo_","stateConfigs_","initialValues_","mixin","setShouldUseFacade","configStateFromStaticHint_","Object","defineProperty","STATE_REF_KEY","configurable","enumerable","value","name","config","required","info","getStateInfo","state","KeyStates","INITIALIZED","get","errorMessage","shouldThrowValidationError","Error","console","error","validatorReturn","getStateKeyValue_","set","val","setStateKeyValue_","fn","args","apply","currentValue","setter","callFunction_","validator","assertValidatorReturnInstanceOfError_","writeOnce","written","configs","names","keys","length","props","i","assertValidStateKeyName_","buildKeyPropertyDef_","defineProperties","assertGivenIfRequired_","validateInitialValue_","ctor","constructor","defineContext","hasConfiguredState_","prototype","configState","getStateStatic","isDisposed","data","emit","opt_names","getStateKeys","warnIfDisposed_","initStateKey_","hasInitialValue_","hasOwnProperty","key","prevVal","shouldInformChange_","newVal","scheduleBatchEvent_","UNINITIALIZED","INITIALIZING","setInitialValue_","setDefaultValue","changeData","nextTick","emitBatchEvent_","changes","hasStateKey","undefined","valueFn","blacklist","values","opt_callback","forEach","once","canSetState","validateKeyValue_","callSetter_","informChange_","callValidator_","disposed","warn","mergeState","mergedVal","currVal"],"mappings":"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","file":"State.js","sourcesContent":["'use strict';\n\nimport { async, getStaticProperty, isDefAndNotNull, isFunction, isObject, isString, object } from 'metal';\nimport { EventEmitter } from 'metal-events';\n\n/**\n * State adds support for having object properties that can be watched for\n * changes, as well as configured with validators, setters and other options.\n * See the `configState` method for a complete list of available configuration\n * options for each state key.\n * @extends {EventEmitter}\n */\nclass State extends EventEmitter {\n\t/**\n\t * Constructor function for `State`.\n\t * @param {Object=} opt_config Optional config object with initial values to\n\t *     set state properties to.\n\t * @param {Object=} opt_obj Optional object that should hold the state\n\t *     properties. If none is given, they will be added directly to `this`\n\t *     instead.\n\t * @param {Object=} opt_context Optional context to call functions (like\n\t *     validators and setters) on. Defaults to `this`.\n\t */\n\tconstructor(opt_config, opt_obj, opt_context) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Context to call functions (like validators and setters) on.\n\t\t * @type {!Object}\n\t\t * @protected\n\t\t */\n\t\tthis.context_ = opt_context || this;\n\n\t\t/**\n\t\t * Map of keys that can not be used as state keys.\n\t\t * @type {Object<string, boolean>}\n\t\t * @protected\n\t\t */\n\t\tthis.keysBlacklist_ = null;\n\n\t\t/**\n\t\t * Object that should hold the state properties.\n\t\t * @type {!Object}\n\t\t * @protected\n\t\t */\n\t\tthis.obj_ = opt_obj || this;\n\n\t\tthis.eventData_ = null;\n\n\t\t/**\n\t\t * Object with information about the batch event that is currently\n\t\t * scheduled, or null if none is.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.scheduledBatchData_ = null;\n\n\t\t/**\n\t\t * Object that contains information about all this instance's state keys.\n\t\t * @type {!Object<string, !Object>}\n\t\t * @protected\n\t\t */\n\t\tthis.stateInfo_ = {};\n\n\t\tthis.stateConfigs_ = {};\n\n\t\tthis.initialValues_ = object.mixin({}, opt_config);\n\n\t\tthis.setShouldUseFacade(true);\n\t\tthis.configStateFromStaticHint_();\n\n\t\tObject.defineProperty(this.obj_, State.STATE_REF_KEY, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: this\n\t\t});\n\t}\n\n\t/**\n\t * Logs an error if the given property is required but wasn't given.\n\t * @param {string} name\n\t * @protected\n\t */\n\tassertGivenIfRequired_(name) {\n\t\tconst config = this.stateConfigs_[name];\n\t\tif (config.required) {\n\t\t\tconst info = this.getStateInfo(name);\n\t\t\tconst value = info.state === State.KeyStates.INITIALIZED ?\n\t\t\t\tthis.get(name) :\n\t\t\t\tthis.initialValues_[name];\n\t\t\tif (!isDefAndNotNull(value)) {\n\t\t\t\tlet errorMessage = `The property called \"${name}\" is required but didn't receive a value.`;\n\t\t\t\tif (this.shouldThrowValidationError()) {\n\t\t\t\t\tthrow new Error(errorMessage);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Logs an error if the `validatorReturn` is instance of `Error`.\n\t * @param {*} validatorReturn\n\t * @protected\n\t */\n\tassertValidatorReturnInstanceOfError_(validatorReturn) {\n\t\tif (validatorReturn instanceof Error) {\n\t\t\tif (this.shouldThrowValidationError()) {\n\t\t\t\tthrow validatorReturn;\n\t\t\t} else {\n\t\t\t\tconsole.error(`Warning: ${validatorReturn}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the given name is a valid state key name. If it's not, an error\n\t * will be thrown.\n\t * @param {string} name The name to be validated.\n\t * @throws {Error}\n\t * @protected\n\t */\n\tassertValidStateKeyName_(name) {\n\t\tif (this.keysBlacklist_ && this.keysBlacklist_[name]) {\n\t\t\tthrow new Error(\n\t\t\t\t`It's not allowed to create a state key with the name \"${name}\".`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Builds the property definition object for the specified state key.\n\t * @param {string} name The name of the key.\n\t * @return {!Object}\n\t * @protected\n\t */\n\tbuildKeyPropertyDef_(name) {\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn this[State.STATE_REF_KEY].getStateKeyValue_(name);\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tthis[State.STATE_REF_KEY].setStateKeyValue_(name, val);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Calls the requested function, running the appropriate code for when it's\n\t * passed as an actual function object or just the function's name.\n\t * @param {!Function|string} fn Function, or name of the function to run.\n\t * @param {!Array} An optional array of parameters to be passed to the\n\t *   function that will be called.\n\t * @return {*} The return value of the called function.\n\t * @protected\n\t */\n\tcallFunction_(fn, args) {\n\t\tif (isString(fn)) {\n\t\t\treturn this.context_[fn].apply(this.context_, args);\n\t\t} else if (isFunction(fn)) {\n\t\t\treturn fn.apply(this.context_, args);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the state key's setter, if there is one.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be set.\n\t * @param {*} currentValue The current value.\n\t * @return {*} The final value to be set.\n\t * @protected\n\t */\n\tcallSetter_(name, value, currentValue) {\n\t\tconst config = this.stateConfigs_[name];\n\t\tif (config.setter) {\n\t\t\tvalue = this.callFunction_(config.setter, [value, currentValue]);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Calls the state key's validator, if there is one. Emits console\n\t * warning if validator returns a string.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t * @protected\n\t */\n\tcallValidator_(name, value) {\n\t\tconst config = this.stateConfigs_[name];\n\t\tif (config.validator) {\n\t\t\tconst validatorReturn = this.callFunction_(\n\t\t\t\tconfig.validator,\n\t\t\t\t[value, name, this.context_]\n\t\t\t);\n\t\t\tthis.assertValidatorReturnInstanceOfError_(validatorReturn);\n\t\t\treturn validatorReturn;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if the it's allowed to write on the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t */\n\tcanSetState(name) {\n\t\tconst info = this.getStateInfo(name);\n\t\treturn !this.stateConfigs_[name].writeOnce || !info.written;\n\t}\n\n\t/**\n\t * Adds the given key(s) to the state, together with its(their) configs.\n\t * Config objects support the given settings:\n\t *     required - When set to `true`, causes errors to be printed (via\n\t *     `console.error`) if no value is given for the property.\n\t *\n\t *     setter - Function for normalizing state key values. It receives the new\n\t *     value that was set, and returns the value that should be stored.\n\t *\n\t *     validator - Function that validates state key values. When it returns\n\t *     false, the new value is ignored. When it returns an instance of Error,\n\t *     it will emit the error to the console.\n\t *\n\t *     value - The default value for the state key. Note that setting this to\n\t *     an object will cause all class instances to use the same reference to\n\t *     the object. To have each instance use a different reference for objects,\n\t *     use the `valueFn` option instead.\n\t *\n\t *     valueFn - A function that returns the default value for a state key.\n\t *\n\t *     writeOnce - Ignores writes to the state key after it's been first\n\t *     written to. That is, allows writes only when setting the value for the\n\t *     first time.\n\t * @param {!Object.<string, !Object>|string} configs An object that maps\n\t *     configuration options for keys to be added to the state.\n\t * @param {boolean|Object|*=} opt_context The context where the added state\n\t *     keys will be defined (defaults to `this`), or false if they shouldn't\n\t *     be defined at all.\n\t */\n\tconfigState(configs, opt_context) {\n\t\tconst names = Object.keys(configs);\n\t\tif (names.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (opt_context !== false) {\n\t\t\tconst props = {};\n\t\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\t\tconst name = names[i];\n\t\t\t\tthis.assertValidStateKeyName_(name);\n\t\t\t\tprops[name] = this.buildKeyPropertyDef_(name);\n\t\t\t}\n\t\t\tObject.defineProperties(\n\t\t\t\topt_context || this.obj_,\n\t\t\t\tprops\n\t\t\t);\n\t\t}\n\n\t\tthis.stateConfigs_ = configs;\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tconst name = names[i];\n\t\t\tconfigs[name] = configs[name].config ? configs[name].config : configs[name];\n\t\t\tthis.assertGivenIfRequired_(names[i]);\n\t\t\tthis.validateInitialValue_(names[i]);\n\t\t}\n\t}\n\n\t/**\n\t * Adds state keys from super classes static hint `MyClass.STATE = {};`.\n\t * @param {Object.<string, !Object>=} opt_config An object that maps all the\n\t *     configurations for state keys.\n\t * @protected\n\t */\n\tconfigStateFromStaticHint_() {\n\t\tconst ctor = this.constructor;\n\t\tif (ctor !== State) {\n\t\t\tlet defineContext;\n\t\t\tif (this.obj_ === this) {\n\t\t\t\tdefineContext = ctor.hasConfiguredState_ ? false : ctor.prototype;\n\t\t\t\tctor.hasConfiguredState_ = true;\n\t\t\t}\n\t\t\tthis.configState(State.getStateStatic(ctor), defineContext);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\t\tthis.initialValues_ = null;\n\t\tthis.stateInfo_ = null;\n\t\tthis.stateConfigs_ = null;\n\t\tthis.scheduledBatchData_ = null;\n\t}\n\n\t/**\n\t * Emits the state change batch event.\n\t * @protected\n\t */\n\temitBatchEvent_() {\n\t\tif (!this.isDisposed()) {\n\t\t\tconst data = this.scheduledBatchData_;\n\t\t\tthis.scheduledBatchData_ = null;\n\t\t\tthis.context_.emit('stateChanged', data);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value of the requested state key.\n\t * Note: this can and should be accomplished by accessing the value as a\n\t * regular property. This should only be used in cases where a function is\n\t * actually needed.\n\t * @param {string} name\n\t * @return {*}\n\t */\n\tget(name) {\n\t\treturn this.obj_[name];\n\t}\n\n\t/**\n\t * Returns an object that maps state keys to their values.\n\t * @param {Array<string>=} opt_names A list of names of the keys that should\n\t *   be returned. If none is given, the whole state will be returned.\n\t * @return {Object.<string, *>}\n\t */\n\tgetState(opt_names) {\n\t\tconst state = {};\n\t\tconst names = opt_names || this.getStateKeys();\n\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tstate[names[i]] = this.get(names[i]);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Gets information about the specified state property.\n\t * @param {string} name\n\t * @return {!Object}\n\t */\n\tgetStateInfo(name) {\n\t\tif (!this.stateInfo_[name]) {\n\t\t\tthis.stateInfo_[name] = {};\n\t\t}\n\t\treturn this.stateInfo_[name];\n\t}\n\n\t/**\n\t * Gets the config object for the requested state key.\n\t * @param {string} name The key's name.\n\t * @return {Object}\n\t * @protected\n\t */\n\tgetStateKeyConfig(name) {\n\t\treturn this.stateConfigs_ ? this.stateConfigs_[name] : null;\n\t}\n\n\t/**\n\t * Returns an array with all state keys.\n\t * @return {!Array.<string>}\n\t */\n\tgetStateKeys() {\n\t\treturn this.stateConfigs_ ? Object.keys(this.stateConfigs_) : [];\n\t}\n\n\t/**\n\t * Gets the value of the specified state key. This is passed as that key's\n\t * getter to the `Object.defineProperty` call inside the `addKeyToState` method.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t * @protected\n\t */\n\tgetStateKeyValue_(name) {\n\t\tif (!this.warnIfDisposed_(name)) {\n\t\t\tthis.initStateKey_(name);\n\t\t\treturn this.getStateInfo(name).value;\n\t\t}\n\t}\n\n\t/**\n\t * Merges the STATE static variable for the given constructor function.\n\t * @param  {!Function} ctor Constructor function.\n\t * @return {boolean} Returns true if merge happens, false otherwise.\n\t * @static\n\t */\n\tstatic getStateStatic(ctor) {\n\t\treturn getStaticProperty(ctor, 'STATE', State.mergeState);\n\t}\n\n\t/**\n\t * Checks if the value of the state key with the given name has already been\n\t * set. Note that this doesn't run the key's getter.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t */\n\thasBeenSet(name) {\n\t\tconst info = this.getStateInfo(name);\n\t\treturn info.state === State.KeyStates.INITIALIZED ||\n\t\t\tthis.hasInitialValue_(name);\n\t}\n\n\t/**\n\t * Checks if an initial value was given to the specified state property.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t * @protected\n\t */\n\thasInitialValue_(name) {\n\t\treturn this.initialValues_.hasOwnProperty(name);\n\t}\n\n\t/**\n\t * Checks if the given key is present in this instance's state.\n\t * @param {string} key\n\t * @return {boolean}\n\t */\n\thasStateKey(key) {\n\t\tif (!this.warnIfDisposed_(key)) {\n\t\t\treturn !!this.stateConfigs_[key];\n\t\t}\n\t}\n\n\t/**\n\t * Informs of changes to a state key's value through an event. Won't trigger\n\t * the event if the value hasn't changed or if it's being initialized.\n\t * @param {string} name The name of the key.\n\t * @param {*} prevVal The previous value of the key.\n\t * @protected\n\t */\n\tinformChange_(name, prevVal) {\n\t\tif (this.shouldInformChange_(name, prevVal)) {\n\t\t\tconst data = object.mixin({\n\t\t\t\tkey: name,\n\t\t\t\tnewVal: this.get(name),\n\t\t\t\tprevVal: prevVal\n\t\t\t}, this.eventData_);\n\t\t\tthis.context_.emit(`${name}Changed`, data);\n\t\t\tthis.context_.emit('stateKeyChanged', data);\n\t\t\tthis.scheduleBatchEvent_(data);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the specified state key, giving it a first value.\n\t * @param {string} name The name of the key.\n\t * @protected\n\t */\n\tinitStateKey_(name) {\n\t\tconst info = this.getStateInfo(name);\n\t\tif (info.state !== State.KeyStates.UNINITIALIZED) {\n\t\t\treturn;\n\t\t}\n\n\t\tinfo.state = State.KeyStates.INITIALIZING;\n\t\tthis.setInitialValue_(name);\n\t\tif (!info.written) {\n\t\t\tthis.setDefaultValue(name);\n\t\t}\n\t\tinfo.state = State.KeyStates.INITIALIZED;\n\t}\n\n\t/**\n\t * Merges two values for the STATE property into a single object.\n\t * @param {Object} mergedVal\n\t * @param {Object} currVal\n\t * @return {!Object} The merged value.\n\t * @static\n\t */\n\tstatic mergeState(mergedVal, currVal) {\n\t\treturn object.mixin({}, currVal, mergedVal);\n\t}\n\n\t/**\n\t * Removes the requested state key.\n\t * @param {string} name The name of the key.\n\t */\n\tremoveStateKey(name) {\n\t\tthis.stateInfo_[name] = null;\n\t\tthis.stateConfigs_[name] = null;\n\t\tdelete this.obj_[name];\n\t}\n\n\t/**\n\t * Schedules a state change batch event to be emitted asynchronously.\n\t * @param {!Object} changeData Information about a state key's update.\n\t * @protected\n\t */\n\tscheduleBatchEvent_(changeData) {\n\t\tif (!this.scheduledBatchData_) {\n\t\t\tasync.nextTick(this.emitBatchEvent_, this);\n\t\t\tthis.scheduledBatchData_ = object.mixin({\n\t\t\t\tchanges: {}\n\t\t\t}, this.eventData_);\n\t\t}\n\n\t\tconst name = changeData.key;\n\t\tconst changes = this.scheduledBatchData_.changes;\n\t\tif (changes[name]) {\n\t\t\tchanges[name].newVal = changeData.newVal;\n\t\t} else {\n\t\t\tchanges[name] = changeData;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the requested state key.\n\t * Note: this can and should be accomplished by setting the state key as a\n\t * regular property. This should only be used in cases where a function is\n\t * actually needed.\n\t * @param {string} name\n\t * @param {*} value\n\t * @return {*}\n\t */\n\tset(name, value) {\n\t\tif (this.hasStateKey(name)) {\n\t\t\tthis.obj_[name] = value;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the default value of the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t */\n\tsetDefaultValue(name) {\n\t\tconst config = this.stateConfigs_[name];\n\n\t\tif (config.value !== undefined) {\n\t\t\tthis.set(name, config.value);\n\t\t} else {\n\t\t\tthis.set(name, this.callFunction_(config.valueFn));\n\t\t}\n\t}\n\n\t/**\n\t * Sets data to be sent with all events emitted from this instance.\n\t * @param {Object}\n\t */\n\tsetEventData(data) {\n\t\tthis.eventData_ = data;\n\t}\n\n\t/**\n\t * Sets the initial value of the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t * @protected\n\t */\n\tsetInitialValue_(name) {\n\t\tif (this.hasInitialValue_(name)) {\n\t\t\tthis.set(name, this.initialValues_[name]);\n\t\t\tthis.initialValues_[name] = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Sets a map of keys that are not valid state keys.\n\t * @param {!Object<string, boolean>}\n\t */\n\tsetKeysBlacklist(blacklist) {\n\t\tthis.keysBlacklist_ = blacklist;\n\t}\n\n\t/**\n\t * Sets the value of all the specified state keys.\n\t * @param {!Object.<string,*>} values A map of state keys to the values they\n\t *   should be set to.\n\t * @param {function()=} opt_callback An optional function that will be run\n\t *   after the next batched update is triggered.\n\t */\n\tsetState(values, opt_callback) {\n\t\tObject.keys(values).forEach(name => this.set(name, values[name]));\n\t\tif (opt_callback && this.scheduledBatchData_) {\n\t\t\tthis.context_.once('stateChanged', opt_callback);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the specified state key. This is passed as that key's\n\t * setter to the `Object.defineProperty` call inside the `addKeyToState`\n\t * method.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The new value of the key.\n\t * @protected\n\t */\n\tsetStateKeyValue_(name, value) {\n\t\tif (this.warnIfDisposed_(name) ||\n\t\t\t!this.canSetState(name) ||\n\t\t\t!this.validateKeyValue_(name, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst prevVal = this.get(name);\n\t\tconst info = this.getStateInfo(name);\n\t\tinfo.value = this.callSetter_(name, value, prevVal);\n\t\tthis.assertGivenIfRequired_(name);\n\t\tinfo.written = true;\n\t\tthis.informChange_(name, prevVal);\n\t}\n\n\t/**\n\t * Checks if we should inform about a state update. Updates are ignored during\n\t * state initialization. Otherwise, updates to primitive values are only\n\t * informed when the new value is different from the previous one. Updates to\n\t * objects (which includes functions and arrays) are always informed outside\n\t * initialization though, since we can't be sure if all of the internal data\n\t * has stayed the same.\n\t * @param {string} name The name of the key.\n\t * @param {*} prevVal The previous value of the key.\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldInformChange_(name, prevVal) {\n\t\tconst info = this.getStateInfo(name);\n\t\treturn (info.state === State.KeyStates.INITIALIZED) &&\n\t\t\t(isObject(prevVal) || prevVal !== this.get(name));\n\t}\n\n\t/**\n\t * Returns a boolean that determines whether or not should throw error when\n\t * vaildator functions returns an `Error` instance.\n\t * @return {boolean} By default returns false.\n\t */\n\tshouldThrowValidationError() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Validates the initial value for the state property with the given name.\n\t * @param {string} name\n\t * @protected\n\t */\n\tvalidateInitialValue_(name) {\n\t\tif (this.hasInitialValue_(name) && !this.callValidator_(name, this.initialValues_[name])) {\n\t\t\tdelete this.initialValues_[name];\n\t\t}\n\t}\n\n\t/**\n\t * Validates the state key's value, which includes calling the validator\n\t * defined in the key's configuration object, if there is one.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t * @protected\n\t */\n\tvalidateKeyValue_(name, value) {\n\t\tconst info = this.getStateInfo(name);\n\t\treturn info.state === State.KeyStates.INITIALIZING ||\n\t\t\tthis.callValidator_(name, value);\n\t}\n\n\t/**\n\t * Warns if this instance has already been disposed.\n\t * @param {string} name Name of the property to be accessed if not disposed.\n\t * @return {boolean} True if disposed, or false otherwise.\n\t * @protected\n\t */\n\twarnIfDisposed_(name) {\n\t\tconst disposed = this.isDisposed();\n\t\tif (disposed) {\n\t\t\tconsole.warn(\n\t\t\t\t`Error. Trying to access property \"${name}\" on disposed instance`\n\t\t\t);\n\t\t}\n\t\treturn disposed;\n\t}\n}\n\nState.STATE_REF_KEY = '__METAL_STATE_REF_KEY__';\n\n/**\n * Constants that represent the states that a state key can be in.\n * @type {!Object}\n */\nState.KeyStates = {\n\tUNINITIALIZED: undefined,\n\tINITIALIZING: 1,\n\tINITIALIZED: 2\n};\n\nexport default State;\n"]}