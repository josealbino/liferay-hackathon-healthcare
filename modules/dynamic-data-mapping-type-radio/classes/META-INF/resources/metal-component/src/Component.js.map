{"version":3,"sources":["Component.js"],"names":["Component","opt_config","opt_parentElement","elementEventProxy_","proxyBlackList_","eventsStateKeyHandler_","inDocument","initialConfig_","wasRendered","DEFAULT_ELEMENT_PARENT","document","body","setShouldUseFacade","element","setUpRenderer_","setUpDataManager_","setUpSyncUpdates_","on","handleComponentStateChanged_","onEventsChanged_","addListenersFromObj_","dataManager_","get","created","componentCreated_","renderComponent","obj","handles","add","opt_siblingElement","attachElement","attachData_","parent","sibling","emit","attached","parentNode","insertBefore","eventName","selector","callback","removeChild","detached","detach","disposed","dispose","renderer_","getState","getStateKeys","prevVal","newVal","setOriginEmitter","syncVisible","event","hasSyncUpdates","updateRenderer_","changes","data","key","syncUpdates_","firstRender","hasRendererRendered_","rendered","class1","class2","removeAllListeners","window","__METAL_DEV_TOOLS_HOOK__","getRenderer","render","attach","state","opt_callback","setState","val","elementClasses","constructor","mergeElementClasses_","trim","setUp","mixin","getExtraDataConfig","DATA","handleComponentStateKeyChanged_","bind","skipUpdates_","style","display","update","elementValue_","prev","handleComponentElementChanged_","fn","prototype","COMPONENT_FLAG","Ctor","opt_configOrElement","opt_element","config","instance","rendererName","RENDERER","RENDERER_NAME","IncrementalDOM","Error","interceptedComponentStrings","patch","patchInterceptor","currentElement","apply","arguments","push","innerHTML","children","validator","Array","isArray","value","setter","events","visible","DATA_MANAGER","ELEMENT_CLASSES","SYNC_UPDATES","eventsChanged","stateChanged","stateKeyChanged"],"mappings":"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","file":"Component.js","sourcesContent":["'use strict';\n\nimport { addListenersFromObj } from './events/events';\nimport { getStaticProperty, isBoolean, isDefAndNotNull, isElement, isObject, isString, object } from 'metal';\nimport { syncState } from './sync/sync';\nimport { DomEventEmitterProxy, toElement } from 'metal-dom';\nimport ComponentDataManager from './ComponentDataManager';\nimport ComponentRenderer from './ComponentRenderer';\nimport { EventEmitter, EventHandler } from 'metal-events';\n\n/**\n * Component collects common behaviors to be followed by UI components, such\n * as Lifecycle, CSS classes management, events encapsulation and support for\n * different types of rendering.\n * Rendering logic can be done by either:\n *     - Listening to the `render` event inside the `created` lifecycle function\n *       and adding the rendering logic to the listener.\n *     - Using an existing implementation of `ComponentRenderer` like `Soy`,\n *       and following its patterns.\n *     - Building your own implementation of a `ComponentRenderer`.\n * Specifying the renderer that will be used can be done by setting the RENDERER\n * static variable to the renderer's constructor function.\n *\n * Example:\n *\n * <code>\n * class CustomComponent extends Component {\n *   created() {\n *   }\n *\n *   rendered() {\n *   }\n *\n *   attached() {\n *   }\n *\n *   detached() {\n *   }\n *\n *   disposed() {\n *   }\n * }\n *\n * CustomComponent.RENDERER = MyRenderer;\n *\n * CustomComponent.STATE = {\n *   title: { value: 'Title' },\n *   fontSize: { value: '10px' }\n * };\n * </code>\n *\n * @extends {State}\n */\nclass Component extends EventEmitter {\n\t/**\n\t * Constructor function for `Component`.\n\t * @param {Object=} opt_config An object with the initial values for this\n\t *     component's state.\n\t * @param {boolean|string|Element=} opt_parentElement The element where the\n\t *     component should be rendered. Can be given as a selector or an element.\n\t *     If `false` is passed, the component won't be rendered automatically\n\t *     after created.\n\t * @constructor\n\t */\n\tconstructor(opt_config, opt_parentElement) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Instance of `DomEventEmitterProxy` which proxies events from the component's\n\t\t * element to the component itself.\n\t\t * @type {!DomEventEmitterProxy}\n\t\t * @protected\n\t\t */\n\t\tthis.elementEventProxy_ = new DomEventEmitterProxy(\n\t\t\tnull,\n\t\t\tthis,\n\t\t\tproxyBlackList_\n\t\t);\n\n\t\t/**\n\t\t * The `EventHandler` instance for events attached from the `events` state key.\n\t\t * @type {EventHandler}\n\t\t * @protected\n\t\t */\n\t\tthis.eventsStateKeyHandler_ = null;\n\n\t\t/**\n\t\t * Whether the element is in document.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.inDocument = false;\n\n\t\t/**\n\t\t * The initial config option passed to this constructor.\n\t\t * @type {!Object}\n\t\t * @protected\n\t\t */\n\t\tthis.initialConfig_ = opt_config || {};\n\n\t\t/**\n\t\t * Whether the element was rendered.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.wasRendered = false;\n\n\t\t/**\n\t\t * The component's element will be appended to the element this variable is\n\t\t * set to, unless the user specifies another parent when calling `render` or\n\t\t * `attach`.\n\t\t * @type {!Element}\n\t\t */\n\t\tthis.DEFAULT_ELEMENT_PARENT = document.body;\n\n\t\tthis.setShouldUseFacade(true);\n\t\tthis.element = this.initialConfig_.element;\n\n\t\tthis.setUpRenderer_();\n\t\tthis.setUpDataManager_();\n\t\tthis.setUpSyncUpdates_();\n\n\t\tthis.on('stateChanged', this.handleComponentStateChanged_);\n\t\tthis.on('eventsChanged', this.onEventsChanged_);\n\t\tthis.addListenersFromObj_(this.dataManager_.get(this, 'events'));\n\n\t\tthis.created();\n\t\tthis.componentCreated_ = true;\n\t\tif (opt_parentElement !== false) {\n\t\t\tthis.renderComponent(opt_parentElement);\n\t\t}\n\t}\n\n\t/**\n\t * Getter logic for the element property.\n\t * @return {Element}\n\t */\n\tget element() {\n\t\treturn this.elementValue_;\n\t}\n\n\t/**\n\t * Adds the listeners specified in the given object.\n\t * @param {!Object} obj\n\t * @protected\n\t */\n\taddListenersFromObj_(obj) {\n\t\tif (!this.eventsStateKeyHandler_) {\n\t\t\tthis.eventsStateKeyHandler_ = new EventHandler();\n\t\t}\n\t\tconst handles = addListenersFromObj(this, obj);\n\t\tthis.eventsStateKeyHandler_.add(...handles);\n\t}\n\n\t/**\n\t * Invokes the attached Lifecycle. When attached, the component element is\n\t * appended to the DOM and any other action to be performed must be\n\t * implemented in this method, such as, binding DOM events. A component can\n\t * be re-attached multiple times.\n\t * @param {(string|Element)=} opt_parentElement Optional parent element\n\t *     to render the component.\n\t * @param {(string|Element)=} opt_siblingElement Optional sibling element\n\t *     to render the component before it. Relevant when the component needs\n\t *     to be rendered before an existing element in the DOM.\n\t * @protected\n\t * @chainable\n\t */\n\tattach(opt_parentElement, opt_siblingElement) {\n\t\tif (!this.inDocument) {\n\t\t\tthis.attachElement(opt_parentElement, opt_siblingElement);\n\t\t\tthis.inDocument = true;\n\t\t\tthis.attachData_ = {\n\t\t\t\tparent: opt_parentElement,\n\t\t\t\tsibling: opt_siblingElement\n\t\t\t};\n\t\t\tthis.emit('attached', this.attachData_);\n\t\t\tthis.attached();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lifecycle. When attached, the component element is appended to the DOM\n\t * and any other action to be performed must be implemented in this method,\n\t * such as, binding DOM events. A component can be re-attached multiple\n\t * times, therefore the undo behavior for any action performed in this phase\n\t * must be implemented on the detach phase.\n\t */\n\tattached() {}\n\n\t/**\n\t * Attaches the component element into the DOM.\n\t * @param {(string|Element)=} opt_parentElement Optional parent element\n\t *     to render the component.\n\t * @param {(string|Element)=} opt_siblingElement Optional sibling element\n\t *     to render the component before it. Relevant when the component needs\n\t *     to be rendered before an existing element in the DOM, e.g.\n\t *     `component.attach(null, existingElement)`.\n\t */\n\tattachElement(opt_parentElement, opt_siblingElement) {\n\t\tconst element = this.element;\n\t\tif (element && (opt_siblingElement || !element.parentNode)) {\n\t\t\tconst parent = toElement(opt_parentElement) || this.DEFAULT_ELEMENT_PARENT;\n\t\t\tparent.insertBefore(element, toElement(opt_siblingElement));\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle. This is called when the component has just been created, before\n\t * it's rendered.\n\t */\n\tcreated() {}\n\n\t/**\n\t * Listens to a delegate event on the component's element.\n\t * @param {string} eventName The name of the event to listen to.\n\t * @param {string} selector The selector that matches the child elements that\n\t *   the event should be triggered for.\n\t * @param {!function(!Object)} callback Function to be called when the event is\n\t *   triggered. It will receive the normalized event object.\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\tdelegate(eventName, selector, callback) {\n\t\treturn this.on(`delegate:${eventName}:${selector}`, callback);\n\t}\n\n\t/**\n\t * Invokes the detached Lifecycle. When detached, the component element is\n\t * removed from the DOM and any other action to be performed must be\n\t * implemented in this method, such as, unbinding DOM events. A component\n\t * can be detached multiple times.\n\t * @chainable\n\t */\n\tdetach() {\n\t\tif (this.inDocument) {\n\t\t\tif (this.element && this.element.parentNode) {\n\t\t\t\tthis.element.parentNode.removeChild(this.element);\n\t\t\t}\n\t\t\tthis.inDocument = false;\n\t\t\tthis.detached();\n\t\t}\n\t\tthis.emit('detached');\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lifecycle. When detached, the component element is removed from the DOM\n\t * and any other action to be performed must be implemented in this method,\n\t * such as, unbinding DOM events. A component can be detached multiple\n\t * times, therefore the undo behavior for any action performed in this phase\n\t * must be implemented on the attach phase.\n\t */\n\tdetached() {}\n\n\t/**\n\t * Lifecycle. Called when the component is disposed. Should be overridden by\n\t * sub classes to dispose of any internal data or events.\n\t */\n\tdisposed() {}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tthis.detach();\n\t\tthis.disposed();\n\n\t\tthis.elementEventProxy_.dispose();\n\t\tthis.elementEventProxy_ = null;\n\n\t\tthis.dataManager_.dispose(this);\n\t\tthis.dataManager_ = null;\n\n\t\tthis.renderer_.dispose(this);\n\t\tthis.renderer_ = null;\n\n\t\tsuper.disposeInternal();\n\t}\n\n\t/**\n\t * Gets data about where this component was attached at.\n\t * @return {!Object}\n\t */\n\tgetAttachData() {\n\t\treturn this.attachData_;\n\t}\n\n\t/**\n\t * Gets the `ComponentDataManager` being used.\n\t * @return {!ComponentDataManager}\n\t */\n\tgetDataManager() {\n\t\treturn this.dataManager_;\n\t}\n\n\t/**\n\t * Gets the configuration object that was passed to this component's constructor.\n\t * @return {!Object}\n\t */\n\tgetInitialConfig() {\n\t\treturn this.initialConfig_;\n\t}\n\n\t/**\n\t * Gets state data for this component.\n\t * @return {!Object}\n\t */\n\tgetState() {\n\t\treturn this.dataManager_.getState(this);\n\t}\n\n\t/**\n\t * Gets the keys for the state data.\n\t * @return {!Array<string>}\n\t */\n\tgetStateKeys() {\n\t\treturn this.dataManager_.getStateKeys(this);\n\t}\n\n\t/**\n\t * Gets the `ComponentRenderer` instance being used.\n\t * @return {!ComponentRenderer}\n\t */\n\tgetRenderer() {\n\t\treturn this.renderer_;\n\t}\n\n\t/**\n\t * Handles a change in the component's element.\n\t * @param {Element} prevVal\n\t * @param {Element} newVal\n\t * @protected\n\t */\n\thandleComponentElementChanged_(prevVal, newVal) {\n\t\tthis.elementEventProxy_.setOriginEmitter(newVal);\n\t\tif (this.componentCreated_) {\n\t\t\tthis.emit('elementChanged', {\n\t\t\t\tprevVal,\n\t\t\t\tnewVal\n\t\t\t});\n\t\t\tif (newVal && this.wasRendered) {\n\t\t\t\tthis.syncVisible(this.dataManager_.get(this, 'visible'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles state batch changes. Calls any existing `sync` functions that\n\t * match the changed state keys.\n\t * @param {Event} event\n\t * @protected\n\t */\n\thandleComponentStateChanged_(event) {\n\t\tif (!this.hasSyncUpdates()) {\n\t\t\tthis.updateRenderer_(event);\n\t\t}\n\t\tsyncState(this, event.changes);\n\t\tthis.emit('stateSynced', event);\n\t}\n\n\t/**\n\t * Handles a `stateKeyChanged` event. This is only called for components that\n\t * have requested updates to happen synchronously.\n\t * @param {!{key: string, newVal: *, prevVal: *}} data\n\t * @protected\n\t */\n\thandleComponentStateKeyChanged_(data) {\n\t\tthis.updateRenderer_({\n\t\t\tchanges: {\n\t\t\t\t[data.key]: data\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if this component has sync updates enabled.\n\t * @return {boolean}\n\t */\n\thasSyncUpdates() {\n\t\treturn this.syncUpdates_;\n\t}\n\n\t/**\n\t * Informs that the component that the rendered has finished rendering it. The\n\t * renderer is the one responsible for calling this when appropriate. This\n\t * will emit events and run the appropriate lifecycle for the first render.\n\t */\n\tinformRendered() {\n\t\tconst firstRender = !this.hasRendererRendered_;\n\t\tthis.hasRendererRendered_ = true;\n\t\tthis.rendered(firstRender);\n\t\tthis.emit('rendered', firstRender);\n\t}\n\n\t/**\n\t * Checks if the given function is a component constructor.\n\t * @param {!function()} fn Any function\n\t * @return {boolean}\n\t */\n\tstatic isComponentCtor(fn) {\n\t\treturn fn.prototype && fn.prototype[Component.COMPONENT_FLAG];\n\t}\n\n\t/**\n\t * Merges two values for the ELEMENT_CLASSES property into a single one.\n\t * @param {string} class1\n\t * @param {string} class2\n\t * @return {string} The merged value.\n\t * @protected\n\t */\n\tmergeElementClasses_(class1, class2) {\n\t\treturn class1 ? class1 + ' ' + (class2 || '') : class2;\n\t}\n\n\t/**\n\t * Fired when the `events` state value is changed.\n\t * @param {!Object} event\n\t * @protected\n\t */\n\tonEventsChanged_(event) {\n\t\tthis.eventsStateKeyHandler_.removeAllListeners();\n\t\tthis.addListenersFromObj_(event.newVal);\n\t}\n\n\t/**\n\t * Creates and renders a component for the given constructor function. This\n\t * will always make sure that the constructor runs without rendering the\n\t * component, having the `render` step happen only after it has finished.\n\t * @param {!function()} Ctor The component's constructor function.\n\t * @param {Object|Element=} opt_configOrElement Optional config data or parent\n\t *     for the component.\n\t * @param {Element=} opt_element Optional parent for the component.\n\t * @return {!Component} The rendered component's instance.\n\t */\n\tstatic render(Ctor, opt_configOrElement, opt_element) {\n\t\tlet config = opt_configOrElement;\n\t\tlet element = opt_element;\n\t\tif (isElement(opt_configOrElement)) {\n\t\t\tconfig = null;\n\t\t\telement = opt_configOrElement;\n\t\t}\n\t\tconst instance = new Ctor(config, false);\n\t\tinstance.renderComponent(element);\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Creates and renders a component for the given constructor function as\n\t * string. This will always make sure that the constructor runs without\n\t * rendering the component, having the `render` step happen only after it\n\t * has finished.\n\t * @param {!function()} Ctor The component's constructor function.\n\t * @param {Object|Element=} opt_configOrElement Optional config data or\n\t *     parent for the component.\n\t * @return {!String} The rendered component's content as string.\n\t */\n\tstatic renderToString(Ctor, opt_config) {\n\t\tconst rendererName = Ctor.RENDERER && Ctor.RENDERER.RENDERER_NAME;\n\t\tswitch (rendererName) {\n\t\t\tcase 'jsx':\n\t\t\tcase 'soy':\n\t\t\tcase 'incremental-dom': {\n\t\t\t\tif (typeof IncrementalDOM === 'undefined') {\n\t\t\t\t\tthrow new Error(`Error. Trying to render incremental dom ` +\n\t\t\t\t\t\t`based component to string requires IncrementalDOM ` +\n\t\t\t\t\t\t`implementation to be loaded.`);\n\t\t\t\t}\n\t\t\t\t// Incremental dom patches for components or nested components are\n\t\t\t\t// isolated inside the component element. The following code intercepts\n\t\t\t\t// incremental dom patches and collect results into temporary stack in\n\t\t\t\t// order to successfully collect the final string of the outermost\n\t\t\t\t// component after all nested components stack rendered.\n\t\t\t\tconst interceptedComponentStrings = [];\n\t\t\t\tconst patch = IncrementalDOM.patch;\n\t\t\t\tconst patchInterceptor = function() {\n\t\t\t\t\tlet currentElement = patch.apply(null, arguments);\n\t\t\t\t\tinterceptedComponentStrings.push(currentElement.innerHTML);\n\t\t\t\t\tIncrementalDOM.patch = patch;\n\t\t\t\t};\n\t\t\t\tIncrementalDOM.patch = patchInterceptor;\n\t\t\t\tComponent.render(Ctor, opt_config).dispose();\n\t\t\t\treturn interceptedComponentStrings[0];\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Error. Trying to render non incremental dom ` +\n\t\t\t\t\t`based component to string.`);\n\t\t}\n\t};\n\n\t/**\n\t * Renders the component into the DOM via its `ComponentRenderer`. Stores the\n\t * given parent element to be used when the renderer is done (`informRendered`).\n\t * @param {(string|Element|boolean)=} opt_parentElement Optional parent element\n\t *     to render the component. If set to `false`, the element won't be\n\t *     attached to any element after rendering. In this case, `attach` should\n\t *     be called manually later to actually attach it to the dom.\n\t */\n\trenderComponent(opt_parentElement) {\n\t\tif (!this.hasRendererRendered_) {\n\t\t\tif (window.__METAL_DEV_TOOLS_HOOK__) {\n\t\t\t\twindow.__METAL_DEV_TOOLS_HOOK__(this);\n\t\t\t}\n\t\t\tthis.getRenderer().render(this);\n\t\t}\n\t\tthis.emit('render');\n\t\tsyncState(this);\n\t\tthis.attach(opt_parentElement);\n\t\tthis.wasRendered = true;\n\t}\n\n\t/**\n\t * Setter logic for the element property.\n\t * @param {?string|Element} val\n\t */\n\tset element(val) {\n\t\tif (!isElement(val) && !isString(val) && isDefAndNotNull(val)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (val) {\n\t\t\tval = toElement(val) || this.elementValue_;\n\t\t}\n\n\t\tif (this.elementValue_ !== val) {\n\t\t\tconst prev = this.elementValue_;\n\t\t\tthis.elementValue_ = val;\n\t\t\tthis.handleComponentElementChanged_(prev, val);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of all the specified state keys.\n\t * @param {!Object.<string,*>} values A map of state keys to the values they\n\t *   should be set to.\n\t * @param {function()=} opt_callback An optional function that will be run\n\t *   after the next batched update is triggered.\n\t */\n\tsetState(state, opt_callback) {\n\t\tthis.dataManager_.setState(this, state, opt_callback);\n\t}\n\n\t/**\n\t * Setter for the `elementClasses` data property. Appends given value with\n\t * the one specified in `ELEMENT_CLASSES`.\n\t * @param {string} val\n\t * @return {string}\n\t * @protected\n\t */\n\tsetterElementClassesFn_(val) {\n\t\tconst elementClasses = getStaticProperty(\n\t\t\tthis.constructor,\n\t\t\t'ELEMENT_CLASSES',\n\t\t\tthis.mergeElementClasses_\n\t\t);\n\t\tif (elementClasses) {\n\t\t\tval += ` ${elementClasses}`;\n\t\t}\n\t\treturn val.trim();\n\t}\n\n\t/**\n\t * Sets up the component's data manager.\n\t * @protected\n\t */\n\tsetUpDataManager_() {\n\t\tthis.dataManager_ = getStaticProperty(this.constructor, 'DATA_MANAGER');\n\t\tthis.dataManager_.setUp(\n\t\t\tthis,\n\t\t\tobject.mixin({}, this.renderer_.getExtraDataConfig(this), Component.DATA)\n\t\t);\n\t}\n\n\t/**\n\t * Sets up the component's renderer.\n\t * @protected\n\t */\n\tsetUpRenderer_() {\n\t\tthis.renderer_ = getStaticProperty(this.constructor, 'RENDERER');\n\t\tthis.renderer_.setUp(this);\n\t}\n\n\t/**\n\t * Sets up the component to use sync updates when `SYNC_UPDATES` is `true`.\n\t * @protected\n\t */\n\tsetUpSyncUpdates_() {\n\t\tthis.syncUpdates_ = getStaticProperty(this.constructor, 'SYNC_UPDATES');\n\t\tif (this.hasSyncUpdates()) {\n\t\t\tthis.on(\n\t\t\t\t'stateKeyChanged',\n\t\t\t\tthis.handleComponentStateKeyChanged_.bind(this)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Skips renderer updates until `stopSkipUpdates` is called.\n\t */\n\tstartSkipUpdates() {\n\t\tthis.skipUpdates_ = true;\n\t}\n\n\t/**\n\t * Stops skipping renderer updates.\n\t */\n\tstopSkipUpdates() {\n\t\tthis.skipUpdates_ = false;\n\t}\n\n\t/**\n\t * State synchronization logic for `visible` state key.\n\t * Updates the element's display value according to its visibility.\n\t * @param {boolean} newVal\n\t */\n\tsyncVisible(newVal) {\n\t\tif (this.element) {\n\t\t\tthis.element.style.display = newVal ? '' : 'none';\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle. Called whenever the component has just been rendered.\n\t * @param {boolean} firstRender Flag indicating if this was the component's\n\t *     first render.\n\t */\n\trendered() {}\n\n\t/**\n\t * Calls \"update\" on the renderer, passing it the changed data.\n\t * @param {!{changes: !Object}} data\n\t * @protected\n\t */\n\tupdateRenderer_(data) {\n\t\tif (!this.skipUpdates_ && this.hasRendererRendered_) {\n\t\t\tthis.getRenderer().update(this, data);\n\t\t}\n\t}\n\n\t/**\n\t * Validator logic for the `events` state key.\n\t * @param {Object} val\n\t * @return {boolean}\n\t * @protected\n\t */\n\tvalidatorEventsFn_(val) {\n\t\treturn !isDefAndNotNull(val) || isObject(val);\n\t}\n}\n\n/**\n * Component data definition.\n * @type {Object}\n * @static\n */\nComponent.DATA = {\n\t/**\n\t * Objects describing children elements that were passed to be rendered inside\n\t * this component.\n\t * @type {!Array<!Object>}\n\t */\n\tchildren: {\n\t\tvalidator: Array.isArray,\n\t\tvalue: []\n\t},\n\n\t/**\n\t * CSS classes to be applied to the element.\n\t * @type {string}\n\t */\n\telementClasses: {\n\t\tsetter: 'setterElementClassesFn_',\n\t\tvalidator: isString,\n\t\tvalue: ''\n\t},\n\n\t/**\n\t * Listeners that should be attached to this component. Should be provided as\n\t * an object, where the keys are event names and the values are the listener\n\t * functions (or function names).\n\t * @type {Object<string, (function()|string|{selector: string, fn: function()|string})>}\n\t */\n\tevents: {\n\t\tvalidator: 'validatorEventsFn_',\n\t\tvalue: null\n\t},\n\n\t/**\n\t * Indicates if the component is visible or not.\n\t * @type {boolean}\n\t */\n\tvisible: {\n\t\tvalidator: isBoolean,\n\t\tvalue: true\n\t}\n};\n\n/**\n * Name of the flag used to identify component constructors via their prototype.\n * @type {string}\n */\nComponent.COMPONENT_FLAG = '__metal_component__';\n\n/**\n * The `ComponentDataManager` class that should be used. This class will be\n * responsible for handling the component's data. Each component may have its\n * own implementation.\n * @type {!ComponentDataManager}\n */\nComponent.DATA_MANAGER = ComponentDataManager;\n\n/**\n * CSS classes to be applied to the element.\n * @type {string}\n */\nComponent.ELEMENT_CLASSES = '';\n\n/**\n * The `ComponentRenderer` that should be used. Components need to set this\n * to a subclass of `ComponentRenderer` that has the rendering logic, like\n * `SoyRenderer`.\n * @type {!ComponentRenderer}\n */\nComponent.RENDERER = ComponentRenderer;\n\n/**\n * Flag indicating if component updates will happen synchronously. Updates are\n * done asynchronously by default, which allows changes to be batched and\n * applied together.\n * @type {boolean}\n */\nComponent.SYNC_UPDATES = false;\n\n/**\n * Sets a prototype flag to easily determine if a given constructor is for\n * a component or not.\n */\nComponent.prototype[Component.COMPONENT_FLAG] = true;\n\nconst proxyBlackList_ = {\n\teventsChanged: true,\n\tstateChanged: true,\n\tstateKeyChanged: true\n};\n\nexport default Component;\n"]}