{"version":3,"sources":["EventEmitterProxy.js"],"names":["EventEmitterProxy","originEmitter","targetEmitter","opt_blacklist","opt_whitelist","blacklist_","originEmitter_","pendingEvents_","proxiedEvents_","targetEmitter_","whitelist_","startProxy_","event","listener","on","removeListeners_","emit","apply","arguments","shouldProxyEvent_","tryToAddListener_","events","Object","keys","i","length","removeListener","forEach","proxyEvent","onListener","bind","addListener_","emitOnTarget_","push"],"mappings":"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","file":"EventEmitterProxy.js","sourcesContent":["'use strict';\n\nimport { Disposable } from 'metal';\n\n/**\n * EventEmitterProxy utility. It's responsible for linking two EventEmitter\n * instances together, emitting events from the first emitter through the\n * second one. That means that listening to a supported event on the target\n * emitter will mean listening to it on the origin emitter as well.\n * @param {EventEmitter} originEmitter Events originated on this emitter\n *   will be fired for the target emitter's listeners as well.\n * @param {EventEmitter} targetEmitter Event listeners attached to this emitter\n *   will also be triggered when the event is fired by the origin emitter.\n * @param {Object} opt_blacklist Optional blacklist of events that should not be\n *   proxied.\n * @constructor\n * @extends {Disposable}\n */\nclass EventEmitterProxy extends Disposable {\n\tconstructor(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Map of events that should not be proxied.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.blacklist_ = opt_blacklist;\n\n\t\t/**\n\t\t * The origin emitter. This emitter's events will be proxied through the\n\t\t * target emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.originEmitter_ = originEmitter;\n\n\t\t/**\n\t\t * A list of events that are pending to be listened by an actual origin\n\t\t * emitter. Events are stored here when the origin doesn't exist, so they\n\t\t * can be set on a new origin when one is set.\n\t\t * @type {Array}\n\t\t * @protected\n\t\t */\n\t\tthis.pendingEvents_ = null;\n\n\t\t/**\n\t\t * Holds a map of events from the origin emitter that are already being proxied.\n\t\t * @type {Object<string, !EventHandle>}\n\t\t * @protected\n\t\t */\n\t\tthis.proxiedEvents_ = null;\n\n\t\t/**\n\t\t * The target emitter. This emitter will emit all events that come from\n\t\t * the origin emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.targetEmitter_ = targetEmitter;\n\n\t\t/**\n\t\t * Map of events that should be proxied. If whitelist is set blacklist is ignored.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.whitelist_ = opt_whitelist;\n\n\t\tthis.startProxy_();\n\t}\n\n\t/**\n\t * Adds the given listener for the given event.\n\t * @param {string} event\n\t * @param {!function()} listener\n\t * @return {!EventHandle} The listened event's handle.\n\t * @protected\n\t */\n\taddListener_(event, listener) {\n\t\treturn this.originEmitter_.on(event, listener);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tthis.removeListeners_();\n\t\tthis.proxiedEvents_ = null;\n\t\tthis.originEmitter_ = null;\n\t\tthis.targetEmitter_ = null;\n\t}\n\n\t/**\n\t * Emits the specified event type on the target emitter.\n\t * @protected\n\t */\n\temitOnTarget_() {\n\t\tthis.targetEmitter_.emit.apply(this.targetEmitter_, arguments);\n\t}\n\n\t/**\n\t * Proxies the given event from the origin to the target emitter.\n\t * @param {string} event\n\t */\n\tproxyEvent(event) {\n\t\tif (this.shouldProxyEvent_(event)) {\n\t\t\tthis.tryToAddListener_(event);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the proxy listener for all events.\n\t * @protected\n\t */\n\tremoveListeners_() {\n\t\tif (this.proxiedEvents_) {\n\t\t\tconst events = Object.keys(this.proxiedEvents_);\n\t\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\t\tthis.proxiedEvents_[events[i]].removeListener();\n\t\t\t}\n\t\t\tthis.proxiedEvents_ = null;\n\t\t}\n\t\tthis.pendingEvents_ = null;\n\t}\n\n\t/**\n\t * Changes the origin emitter. This automatically detaches any events that\n\t * were already being proxied from the previous emitter, and starts proxying\n\t * them on the new emitter instead.\n\t * @param {!EventEmitter} originEmitter\n\t */\n\tsetOriginEmitter(originEmitter) {\n\t\tconst events = this.originEmitter_ && this.proxiedEvents_ ?\n\t\t\tObject.keys(this.proxiedEvents_) :\n\t\t\tthis.pendingEvents_;\n\t\tthis.originEmitter_ = originEmitter;\n\t\tif (events) {\n\t\t\tthis.removeListeners_();\n\t\t\tevents.forEach(event => this.proxyEvent(event));\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given event should be proxied.\n\t * @param {string} event\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldProxyEvent_(event) {\n\t\tif (this.whitelist_ && !this.whitelist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.blacklist_ && this.blacklist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this.proxiedEvents_ || !this.proxiedEvents_[event];\n\t}\n\n\t/**\n\t * Starts proxying all events from the origin to the target emitter.\n\t * @protected\n\t */\n\tstartProxy_() {\n\t\tthis.targetEmitter_.onListener(this.proxyEvent.bind(this));\n\t}\n\n\t/**\n\t * Adds a listener to the origin emitter, if it exists. Otherwise, stores\n\t * the pending listener so it can be used on a future origin emitter.\n\t * @param {string} event\n\t * @protected\n\t */\n\ttryToAddListener_(event) {\n\t\tif (this.originEmitter_) {\n\t\t\tthis.proxiedEvents_ = this.proxiedEvents_ || {};\n\t\t\tthis.proxiedEvents_[event] = this.addListener_(\n\t\t\t\tevent,\n\t\t\t\tthis.emitOnTarget_.bind(this, event)\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pendingEvents_ = this.pendingEvents_ || [];\n\t\t\tthis.pendingEvents_.push(event);\n\t\t}\n\t}\n}\n\nexport default EventEmitterProxy;\n"]}