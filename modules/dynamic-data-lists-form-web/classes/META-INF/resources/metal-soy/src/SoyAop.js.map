{"version":3,"sources":["SoyAop.js"],"names":["SoyAop","interceptFns_","getOriginalFn","fn","originalFn","handleTemplateCall_","opt_data","opt_ignored","opt_ijData","interceptFn","length","call","registerForInterception","templates","name","bind","startInterception","push","stopAllInterceptions","stopInterception","pop"],"mappings":";AAAA;;;;;AAEA,KAAMA,SAAS;AACd;;;;;;;AAOAC,iBAAe,EARD;;AAUd;;;;;;AAMAC,iBAAe,uBAASC,EAAT,EAAa;AAC3B,UAAOA,GAAGC,UAAH,GAAgBD,GAAGC,UAAnB,GAAgCD,EAAvC;AACA,GAlBa;;AAoBd;;;;;;;;;;;AAWAE,uBAAqB,6BAASD,UAAT,EAAqBE,QAArB,EAA+BC,WAA/B,EAA4CC,UAA5C,EAAwD;AAC5E,OAAMC,cAAcT,OAAOC,aAAP,CAAqBD,OAAOC,aAAP,CAAqBS,MAArB,GAA8B,CAAnD,CAApB;AACA,OAAID,WAAJ,EAAiB;AAChB,WAAOA,YAAYE,IAAZ,CAAiB,IAAjB,EAAuBP,UAAvB,EAAmCE,QAAnC,EAA6CC,WAA7C,EAA0DC,UAA1D,CAAP;AACA,IAFD,MAEO;AACN,WAAOJ,WAAWO,IAAX,CAAgB,IAAhB,EAAsBL,QAAtB,EAAgCC,WAAhC,EAA6CC,UAA7C,CAAP;AACA;AACD,GAtCa;;AAwCd;;;;;;AAMAI,2BAAyB,iCAASC,SAAT,EAAoBC,IAApB,EAA0B;AAClD,OAAMV,aAAaS,UAAUC,IAAV,CAAnB;AACA,OAAI,CAACV,WAAWA,UAAhB,EAA4B;AAC3BS,cAAUC,IAAV,IAAkBd,OAAOK,mBAAP,CAA2BU,IAA3B,CAAgC,IAAhC,EAAsCX,UAAtC,CAAlB;AACAS,cAAUC,IAAV,EAAgBV,UAAhB,GAA6BA,UAA7B;AACA;AACD,GApDa;;AAsDd;;;;;AAKAY,qBAAmB,2BAASb,EAAT,EAAa;AAC/BH,UAAOC,aAAP,CAAqBgB,IAArB,CAA0Bd,EAA1B;AACA,GA7Da;;AA+Dd;;;AAGAe,wBAAsB,gCAAW;AAChClB,UAAOC,aAAP,GAAuB,EAAvB;AACA,GApEa;;AAsEd;;;AAGAkB,oBAAkB,4BAAW;AAC5BnB,UAAOC,aAAP,CAAqBmB,GAArB;AACA;AA3Ea,EAAf;;mBA8EepB,M","file":"SoyAop.js","sourcesContent":["'use strict';\n\nconst SoyAop = {\n\t/**\n\t * The functions that should be called instead of a template call. The last\n\t * function in the array is the one that is intercepting at the moment. If the\n\t * array is empty, the original function will be called instead.\n\t * @type {!Array<function()>}\n\t * @protected\n\t */\n\tinterceptFns_: [],\n\n\t/**\n\t * Gets the original function of the given template function. If no original exists,\n\t * returns the given function itself.\n\t * @param {!function()} fn\n\t * @return {!function()}\n\t */\n\tgetOriginalFn: function(fn) {\n\t\treturn fn.originalFn ? fn.originalFn : fn;\n\t},\n\n\t/**\n\t * Handles a template call, calling the current interception function if one\n\t * is set, or otherwise just calling the original function instead.\n\t * @param {!function()} originalFn The original template function that was\n\t *     intercepted.\n\t * @param {Object} opt_data Template data object.\n\t * @param {*} opt_ignored\n\t * @param {Object} opt_ijData Template injected data object.\n\t * @return {*} The return value of the function that is called to handle this\n\t *     interception.\n\t */\n\thandleTemplateCall_: function(originalFn, opt_data, opt_ignored, opt_ijData) {\n\t\tconst interceptFn = SoyAop.interceptFns_[SoyAop.interceptFns_.length - 1];\n\t\tif (interceptFn) {\n\t\t\treturn interceptFn.call(null, originalFn, opt_data, opt_ignored, opt_ijData);\n\t\t} else {\n\t\t\treturn originalFn.call(null, opt_data, opt_ignored, opt_ijData);\n\t\t}\n\t},\n\n\t/**\n\t * Registers a template function that should be intercepted.\n\t * @param {!Object} templates The original templates object containing the\n\t *     function to be intercepted.\n\t * @param {string} name The name of the template function to intercept.\n\t */\n\tregisterForInterception: function(templates, name) {\n\t\tconst originalFn = templates[name];\n\t\tif (!originalFn.originalFn) {\n\t\t\ttemplates[name] = SoyAop.handleTemplateCall_.bind(null, originalFn);\n\t\t\ttemplates[name].originalFn = originalFn;\n\t\t}\n\t},\n\n\t/**\n\t * Starts intercepting all template calls, replacing them with a call to the\n\t * given function instead.\n\t * @param {!function()} fn\n\t */\n\tstartInterception: function(fn) {\n\t\tSoyAop.interceptFns_.push(fn);\n\t},\n\n\t/**\n\t * Stops intercepting template calls.\n\t */\n\tstopAllInterceptions: function() {\n\t\tSoyAop.interceptFns_ = [];\n\t},\n\n\t/**\n\t * Stops intercepting template calls with the last registered function.\n\t */\n\tstopInterception: function() {\n\t\tSoyAop.interceptFns_.pop();\n\t}\n};\n\nexport default SoyAop;\n"]}