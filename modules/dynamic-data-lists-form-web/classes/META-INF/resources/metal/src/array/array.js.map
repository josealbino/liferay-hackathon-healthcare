{"version":3,"sources":["array.js"],"names":["array","arr1","arr2","length","i","arr","undefined","opt_output","output","Array","isArray","flatten","push","obj","indexOf","rv","removeAt","prototype","splice","call","start","opt_end","sliced","end"],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAIMA,K;;;;;;;yBAOQC,I,EAAMC,I,EAAM;AACxB,QAAID,SAASC,IAAb,EAAmB;AAClB,YAAO,IAAP;AACA;AACD,QAAID,KAAKE,MAAL,KAAgBD,KAAKC,MAAzB,EAAiC;AAChC,YAAO,KAAP;AACA;AACD,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIH,KAAKE,MAAzB,EAAiCC,GAAjC,EAAsC;AACrC,SAAIH,KAAKG,CAAL,MAAYF,KAAKE,CAAL,CAAhB,EAAyB;AACxB,aAAO,KAAP;AACA;AACD;AACD,WAAO,IAAP;AACA;;;qCAOwBC,G,EAAK;AAC7B,SAAK,IAAID,IAAI,CAAb,EAAgBA,IAAIC,IAAIF,MAAxB,EAAgCC,GAAhC,EAAqC;AACpC,SAAIC,IAAID,CAAJ,MAAWE,SAAf,EAA0B;AACzB,aAAOD,IAAID,CAAJ,CAAP;AACA;AACD;AACD;;;2BAQcC,G,EAAKE,U,EAAY;AAC/B,QAAIC,SAASD,cAAc,EAA3B;AACA,SAAK,IAAIH,IAAI,CAAb,EAAgBA,IAAIC,IAAIF,MAAxB,EAAgCC,GAAhC,EAAqC;AACpC,SAAIK,MAAMC,OAAN,CAAcL,IAAID,CAAJ,CAAd,CAAJ,EAA2B;AAC1BJ,YAAMW,OAAN,CAAcN,IAAID,CAAJ,CAAd,EAAsBI,MAAtB;AACA,MAFD,MAEO;AACNA,aAAOI,IAAP,CAAYP,IAAID,CAAJ,CAAZ;AACA;AACD;AACD,WAAOI,MAAP;AACA;;;0BASaH,G,EAAKQ,G,EAAK;AACvB,QAAMT,IAAIC,IAAIS,OAAJ,CAAYD,GAAZ,CAAV;AACA,QAAIE,WAAJ;AACA,QAAMA,KAAKX,KAAK,CAAhB,EAAqB;AACpBJ,WAAMgB,QAAN,CAAeX,GAAf,EAAoBD,CAApB;AACA;AACD,WAAOW,EAAP;AACA;;;4BAQeV,G,EAAKD,C,EAAG;AACvB,WAAOK,MAAMQ,SAAN,CAAgBC,MAAhB,CAAuBC,IAAvB,CAA4Bd,GAA5B,EAAiCD,CAAjC,EAAoC,CAApC,EAAuCD,MAAvC,KAAkD,CAAzD;AACA;;;yBAYYE,G,EAAKe,K,EAAOC,O,EAAS;AACjC,QAAMC,SAAS,EAAf;AACA,QAAMC,MAAM,iBAAMF,OAAN,IAAiBA,OAAjB,GAA2BhB,IAAIF,MAA3C;AACA,SAAK,IAAIC,IAAIgB,KAAb,EAAoBhB,IAAImB,GAAxB,EAA6BnB,GAA7B,EAAkC;AACjCkB,YAAOV,IAAP,CAAYP,IAAID,CAAJ,CAAZ;AACA;AACD,WAAOkB,MAAP;AACA;;;;;;mBAGatB,K","file":"array.js","sourcesContent":["'use strict';\n\nimport { isDef } from '../core';\n\nclass array {\n\t/**\n\t * Checks if the given arrays have the same content.\n\t * @param {!Array<*>} arr1\n\t * @param {!Array<*>} arr2\n\t * @return {boolean}\n\t */\n\tstatic equal(arr1, arr2) {\n\t\tif (arr1 === arr2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (arr1.length !== arr2.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < arr1.length; i++) {\n\t\t\tif (arr1[i] !== arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the first value in the given array that isn't undefined.\n\t * @param {!Array} arr\n\t * @return {*}\n\t */\n\tstatic firstDefinedValue(arr) {\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i] !== undefined) {\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Transforms the input nested array to become flat.\n\t * @param {Array.<*|Array.<*>>} arr Nested array to flatten.\n\t * @param {Array.<*>} opt_output Optional output array.\n\t * @return {Array.<*>} Flat array.\n\t */\n\tstatic flatten(arr, opt_output) {\n\t\tvar output = opt_output || [];\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tif (Array.isArray(arr[i])) {\n\t\t\t\tarray.flatten(arr[i], output);\n\t\t\t} else {\n\t\t\t\toutput.push(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Removes the first occurrence of a particular value from an array.\n\t * @param {Array.<T>} arr Array from which to remove value.\n\t * @param {T} obj Object to remove.\n\t * @return {boolean} True if an element was removed.\n\t * @template T\n\t */\n\tstatic remove(arr, obj) {\n\t\tconst i = arr.indexOf(obj);\n\t\tlet rv;\n\t\tif ( (rv = i >= 0) ) {\n\t\t\tarray.removeAt(arr, i);\n\t\t}\n\t\treturn rv;\n\t}\n\n\t/**\n\t * Removes from an array the element at index i\n\t * @param {Array} arr Array or array like object from which to remove value.\n\t * @param {number} i The index to remove.\n\t * @return {boolean} True if an element was removed.\n\t */\n\tstatic removeAt(arr, i) {\n\t\treturn Array.prototype.splice.call(arr, i, 1).length === 1;\n\t}\n\n\t/**\n\t * Slices the given array, just like Array.prototype.slice, but this\n\t * is faster and working on all array-like objects (like arguments).\n\t * @param {!Object} arr Array-like object to slice.\n\t * @param {number} start The index that should start the slice.\n\t * @param {number=} opt_end The index where the slice should end, not\n\t *   included in the final array. If not given, all elements after the\n\t *   start index will be included.\n\t * @return {!Array}\n\t */\n\tstatic slice(arr, start, opt_end) {\n\t\tconst sliced = [];\n\t\tconst end = isDef(opt_end) ? opt_end : arr.length;\n\t\tfor (let i = start; i < end; i++) {\n\t\t\tsliced.push(arr[i]);\n\t\t}\n\t\treturn sliced;\n\t}\n}\n\nexport default array;\n"]}