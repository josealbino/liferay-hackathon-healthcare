{"version":3,"sources":["incremental-dom-cjs.js"],"names":["hasOwnProperty","Object","prototype","Blank","create","has","map","property","call","createMap","NodeData","nodeName","key","attrs","attrsArr","newAttrs","staticsApplied","keyMap","keyMapValid","focused","text","initData","node","data","getData","importNode","isElement","Element","localName","getAttribute","parentNode","attributes","i","length","attr","name","value","undefined","push","child","firstChild","nextSibling","getNamespaceForTag","tag","parent","namespaceURI","createElement","doc","namespace","el","createElementNS","createText","createTextNode","notifications","nodesCreated","nodesDeleted","Context","created","deleted","markCreated","markDeleted","notifyChanges","inAttributes","inSkip","assertInPatch","functionName","context","Error","assertNoUnclosedTags","openElement","root","currentElement","openTags","toLowerCase","join","assertNotInAttributes","assertNotInSkip","assertInAttributes","assertVirtualAttributesClosed","assertCloseMatchesOpenTag","assertNoChildrenDeclaredYet","previousNode","assertPatchElementNoExtras","startNode","currentNode","expectedNextNode","expectedPrevNode","wasUpdated","previousSibling","wasChanged","wasRemoved","setInAttributes","previous","setInSkip","isDocumentRoot","Document","DocumentFragment","getAncestry","ancestry","cur","getRoot","prev","getActiveElement","activeElement","getFocusedPath","contains","moveBefore","referenceNode","insertReferenceNode","next","insertBefore","currentParent","markFocused","focusPath","patchFactory","run","f","fn","prevContext","prevDoc","prevCurrentNode","prevCurrentParent","previousInAttributes","previousInSkip","ownerDocument","process","env","NODE_ENV","retVal","patchInner","enterNode","exitNode","patchOuter","removeChild","matches","matchNode","alignWithDOM","parentData","currentNodeData","keyNode","replaceChild","clearUnvisitedDOM","lastChild","getNextNode","nextNode","coreElementOpen","coreElementClose","coreText","currentPointer","skip","skipNode","symbols","default","getNamespace","lastIndexOf","applyAttr","removeAttribute","attrNS","setAttributeNS","setAttribute","applyProp","setStyleValue","style","prop","indexOf","setProperty","applyStyle","cssText","elStyle","obj","applyAttributeTyped","type","updateAttribute","mutator","ATTRIBUTES_OFFSET","argsBuilder","elementOpen","statics","var_args","_i","isNew","j","arguments","_attr","_attr2","elementOpenStart","elementOpenEnd","apply","elementClose","elementVoid","formatted","exports","patch"],"mappings":"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","file":"incremental-dom-cjs.js","sourcesContent":["\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A constructor function that will create blank objects.\n * @constructor\n */\nfunction Blank() {}\n\nBlank.prototype = Object.create(null);\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return new Blank();\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * Whether or not the statics have been applied for the node yet.\n   * {boolean}\n   */\n  this.staticsApplied = false;\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {!Object<string, !Element>}\n   */\n  this.keyMap = createMap();\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * @type {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * Whether or the associated node is, or contains, a focused Element.\n   * @type {boolean}\n   */\n  this.focused = false;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {?Node} node The Node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  importNode(node);\n  return node['__incrementalDOMData'];\n};\n\n/**\n * Imports node and its subtree, initializing caches.\n *\n * @param {?Node} node The Node to import.\n */\nvar importNode = function (node) {\n  if (node['__incrementalDOMData']) {\n    return;\n  }\n\n  var isElement = node instanceof Element;\n  var nodeName = isElement ? node.localName : node.nodeName;\n  var key = isElement ? node.getAttribute('key') : null;\n  var data = initData(node, nodeName, key);\n\n  if (key) {\n    getData(node.parentNode).keyMap[key] = node;\n  }\n\n  if (isElement) {\n    var attributes = node.attributes;\n    var attrs = data.attrs;\n    var newAttrs = data.newAttrs;\n    var attrsArr = data.attrsArr;\n\n    for (var i = 0; i < attributes.length; i += 1) {\n      var attr = attributes[i];\n      var name = attr.name;\n      var value = attr.value;\n\n      attrs[name] = value;\n      newAttrs[name] = undefined;\n      attrsArr.push(name);\n      attrsArr.push(value);\n    }\n  }\n\n  for (var child = node.firstChild; child; child = child.nextSibling) {\n    importNode(child);\n  }\n};\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nvar inAttributes = false;\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nvar inSkip = false;\n\n/**\n * Makes sure that there is a current patch context.\n * @param {string} functionName\n * @param {*} context\n */\nvar assertInPatch = function (functionName, context) {\n  if (!context) {\n    throw new Error('Cannot call ' + functionName + '() unless in patch.');\n  }\n};\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nvar assertNoUnclosedTags = function (openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  var currentElement = openElement;\n  var openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n};\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nvar assertNotInAttributes = function (functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() can not be called between ' + 'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nvar assertNotInSkip = function (functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' + 'that has called skip().');\n  }\n};\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nvar assertInAttributes = function (functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() can only be called after calling ' + 'elementOpenStart().');\n  }\n};\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nvar assertVirtualAttributesClosed = function () {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' + 'elementOpenStart().');\n  }\n};\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nvar assertCloseMatchesOpenTag = function (nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close \"' + tag + '\" but \"' + nodeName + '\" was open.');\n  }\n};\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nvar assertNoChildrenDeclaredYet = function (functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' + 'declarations inside the current element.');\n  }\n};\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} startNode The value for the currentNode when the patch\n *     started.\n * @param {?Node} currentNode The currentNode when the patch finished.\n * @param {?Node} expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param {?Node} expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nvar assertPatchElementNoExtras = function (startNode, currentNode, expectedNextNode, expectedPrevNode) {\n  var wasUpdated = currentNode.nextSibling === expectedNextNode && currentNode.previousSibling === expectedPrevNode;\n  var wasChanged = currentNode.nextSibling === startNode.nextSibling && currentNode.previousSibling === expectedPrevNode;\n  var wasRemoved = currentNode === startNode;\n\n  if (!wasUpdated && !wasChanged && !wasRemoved) {\n    throw new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');\n  }\n};\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInAttributes = function (value) {\n  var previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInSkip = function (value) {\n  var previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n/**\n * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @param {!Node} node\n * @return {boolean} True if the node the root of a document, false otherwise.\n */\nvar isDocumentRoot = function (node) {\n  // For ShadowRoots, check if they are a DocumentFragment instead of if they\n  // are a ShadowRoot so that this can work in 'use strict' if ShadowRoots are\n  // not supported.\n  return node instanceof Document || node instanceof DocumentFragment;\n};\n\n/**\n * @param {!Node} node The node to start at, inclusive.\n * @param {?Node} root The root ancestor to get until, exclusive.\n * @return {!Array<!Node>} The ancestry of DOM nodes.\n */\nvar getAncestry = function (node, root) {\n  var ancestry = [];\n  var cur = node;\n\n  while (cur !== root) {\n    ancestry.push(cur);\n    cur = cur.parentNode;\n  }\n\n  return ancestry;\n};\n\n/**\n * @param {!Node} node\n * @return {!Node} The root node of the DOM tree that contains node.\n */\nvar getRoot = function (node) {\n  var cur = node;\n  var prev = cur;\n\n  while (cur) {\n    prev = cur;\n    cur = cur.parentNode;\n  }\n\n  return prev;\n};\n\n/**\n * @param {!Node} node The node to get the activeElement for.\n * @return {?Element} The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nvar getActiveElement = function (node) {\n  var root = getRoot(node);\n  return isDocumentRoot(root) ? root.activeElement : null;\n};\n\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param {!Node} node The reference node to get the activeElement for.\n * @param {?Node} root The root to get the focused path until.\n * @return {!Array<Node>}\n */\nvar getFocusedPath = function (node, root) {\n  var activeElement = getActiveElement(node);\n\n  if (!activeElement || !node.contains(activeElement)) {\n    return [];\n  }\n\n  return getAncestry(activeElement, root);\n};\n\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param {?Node} parentNode\n * @param {!Node} node\n * @param {?Node} referenceNode\n */\nvar moveBefore = function (parentNode, node, referenceNode) {\n  var insertReferenceNode = node.nextSibling;\n  var cur = referenceNode;\n\n  while (cur !== node) {\n    var next = cur.nextSibling;\n    parentNode.insertBefore(cur, insertReferenceNode);\n    cur = next;\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * @param {!Array<Node>} focusPath The nodes to mark.\n * @param {boolean} focused Whether or not they are focused.\n */\nvar markFocused = function (focusPath, focused) {\n  for (var i = 0; i < focusPath.length; i += 1) {\n    getData(focusPath[i]).focused = focused;\n  }\n};\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @return {?Node} node\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    var focusPath = getFocusedPath(node, currentParent);\n    markFocused(focusPath, true);\n    var retVal = run(node, fn, data);\n    markFocused(focusPath, false);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertVirtualAttributesClosed();\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n    }\n\n    context.notifyChanges();\n\n    context = prevContext;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n\n    return retVal;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {!Node} The patched node.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(currentNode, node);\n  }\n\n  return node;\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {?Node} The node if it was updated, its replacedment or null if it\n *     was removed.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  var startNode = /** @type {!Element} */{ nextSibling: node };\n  var expectedNextNode = null;\n  var expectedPrevNode = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    expectedNextNode = node.nextSibling;\n    expectedPrevNode = node.previousSibling;\n  }\n\n  currentNode = startNode;\n  fn(data);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertPatchElementNoExtras(startNode, currentNode, expectedNextNode, expectedPrevNode);\n  }\n\n  if (node !== currentNode && node.parentNode) {\n    removeChild(currentParent, node, getData(currentParent).keyMap);\n  }\n\n  return startNode === currentNode ? null : currentNode;\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {!Node} matchNode A node to match the data to.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (matchNode, nodeName, key) {\n  var data = getData(matchNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n */\nvar alignWithDOM = function (nodeName, key) {\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    return;\n  }\n\n  var parentData = getData(currentParent);\n  var currentNodeData = currentNode && getData(currentNode);\n  var keyMap = parentData.keyMap;\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    var keyNode = keyMap[key];\n    if (keyNode) {\n      if (matches(keyNode, nodeName, key)) {\n        node = keyNode;\n      } else if (keyNode === currentNode) {\n        context.markDeleted(keyNode);\n      } else {\n        removeChild(currentParent, keyNode, keyMap);\n      }\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key);\n    }\n\n    if (key) {\n      keyMap[key] = node;\n    }\n\n    context.markCreated(node);\n  }\n\n  // Re-order the node into the right position, preserving focus if either\n  // node or currentNode are focused by making sure that they are not detached\n  // from the DOM.\n  if (getData(node).focused) {\n    // Move everything else before the node.\n    moveBefore(currentParent, node, currentNode);\n  } else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {\n    // Remove the currentNode, which can always be added back since we hold a\n    // reference through the keyMap. This prevents a large number of moves when\n    // a keyed item is removed or moved backwards in the DOM.\n    currentParent.replaceChild(node, currentNode);\n    parentData.keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * @param {?Node} node\n * @param {?Node} child\n * @param {?Object<string, !Element>} keyMap\n */\nvar removeChild = function (node, child, keyMap) {\n  node.removeChild(child);\n  context.markDeleted( /** @type {!Node}*/child);\n\n  var key = getData(child).key;\n  if (key) {\n    delete keyMap[key];\n  }\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  while (child !== currentNode) {\n    removeChild(node, child, keyMap);\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * @return {?Node} The next Node to be patched.\n */\nvar getNextNode = function () {\n  if (currentNode) {\n    return currentNode.nextSibling;\n  } else {\n    return currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  currentNode = getNextNode();\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key) {\n  nextNode();\n  alignWithDOM(tag, key);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentElement', context);\n    assertNotInAttributes('currentElement');\n  }\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * @return {Node} The Node that will be evaluated for the next instruction.\n */\nvar currentPointer = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentPointer', context);\n    assertNotInAttributes('currentPointer');\n  }\n  return getNextNode();\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * Skips the next Node to be patched, moving the pointer forward to the next\n * sibling of the current pointer.\n */\nvar skipNode = nextNode;\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n * @param {CSSStyleDeclaration} style\n * @param {!string} prop\n * @param {*} value\n */\nvar setStyleValue = function (style, prop, value) {\n  if (prop.indexOf('-') >= 0) {\n    style.setProperty(prop, /** @type {string} */value);\n  } else {\n    style[prop] = value;\n  }\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        setStyleValue(elStyle, prop, obj[prop]);\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes['style'] = applyStyle;\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  var node = coreElementOpen(tag, key);\n  var data = getData(node);\n\n  if (!data.staticsApplied) {\n    if (statics) {\n      for (var _i = 0; _i < statics.length; _i += 2) {\n        var name = /** @type {string} */statics[_i];\n        var value = statics[_i + 1];\n        updateAttribute(node, name, value);\n      }\n    }\n    // Down the road, we may want to keep track of the statics array to use it\n    // as an additional signal about whether a node matches or not. For now,\n    // just use a marker so that we do not reapply statics.\n    data.staticsApplied = true;\n  }\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var isNew = !attrsArr.length;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    var _attr = arguments[i];\n    if (isNew) {\n      attrsArr[j] = _attr;\n      newAttrs[_attr] = undefined;\n    } else if (attrsArr[j] !== _attr) {\n      break;\n    }\n\n    var value = arguments[i + 1];\n    if (isNew || attrsArr[j + 1] !== value) {\n      attrsArr[j + 1] = value;\n      updateAttribute(node, _attr, value);\n    }\n  }\n\n  if (i < arguments.length || j < attrsArr.length) {\n    for (; i < arguments.length; i += 1, j += 1) {\n      attrsArr[j] = arguments[i];\n    }\n\n    if (j < attrsArr.length) {\n      attrsArr.length = j;\n    }\n\n    /*\n     * Actually perform the attribute update.\n     */\n    for (i = 0; i < attrsArr.length; i += 2) {\n      var name = /** @type {string} */attrsArr[i];\n      var value = attrsArr[i + 1];\n      newAttrs[name] = value;\n    }\n\n    for (var _attr2 in newAttrs) {\n      updateAttribute(node, _attr2, newAttrs[_attr2]);\n      newAttrs[_attr2] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  var node = coreElementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, var_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.currentPointer = currentPointer;\nexports.skip = skip;\nexports.skipNode = skipNode;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\nexports.importNode = importNode;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map"]}