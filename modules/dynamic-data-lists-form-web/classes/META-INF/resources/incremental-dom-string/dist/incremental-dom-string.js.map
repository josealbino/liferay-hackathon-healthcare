{"version":3,"sources":["incremental-dom-string.js"],"names":["global","factory","exports","module","define","amd","IncrementalDOM","buffer","currentParent","currentElement","currentPointer","patch","node","fn","data","innerHTML","join","patchOuter","patchInner","text","value","var_args","formatted","i","arguments","length","push","symbols","default","attributes","updateAttribute","el","name","mutator","Array","isArray","truncateArray","arr","pop","ATTRIBUTES_OFFSET","argsBuilder","attr","elementClose","nameOrCtor","elementVoid","key","statics","elementOpen","apply","_i","j","_name","_value","elementOpenEnd","elementOpenStart","renderToString","Object","defineProperty"],"mappings":"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","file":"incremental-dom-string.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.IncrementalDOM = global.IncrementalDOM || {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * An array used to store the strings generated by calls to\n * elementOpen, elementOpenStart, elementOpenEnd, elementEnd and elementVoid\n */\nexports.buffer = [];\n\n/** @type {?Object} */\nexports.currentParent = null;\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function currentElement() {\n  return exports.currentParent;\n};\n\n/**\n * @return {Node} The Node that will be evaluated for the next instruction.\n */\nvar currentPointer = function currentPointer() {\n  return {};\n};\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n *\n * @param {?object} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing open/close/etc. calls that\n *     describe the DOM. This should have at most one top level element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {void} Nothing.\n */\nvar patch = function patch(node, fn, data) {\n  exports.currentParent = node;\n  fn(data);\n  exports.currentParent.innerHTML = exports.buffer.join('');\n  exports.buffer = [];\n  return exports.currentParent;\n};\n\nvar patchOuter = patch;\nvar patchInner = patch;\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n *\n * @return {void} Nothing.\n */\nvar text = function text(value, var_args) {\n  var formatted = value;\n  for (var i = 1; i < arguments.length; i += 1) {\n    var fn = arguments[i];\n    formatted = fn(formatted);\n  }\n  exports.buffer.push(formatted);\n};\n\n/** @const */\nvar symbols = {\n  default: '__default'\n};\n\n/** @const */\nvar attributes = {};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Array.<string>} el Buffer to append element attributes.\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function updateAttribute(el, name, value) {\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n};\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = function (el, name, value) {\n  if (Array.isArray(el)) {\n    el.push(' ' + name + '=\"' + value + '\"');\n  }\n};\n\n/**\n * Truncates an array, removing items up until length.\n * @param {!Array<*>} arr The array to truncate.\n * @param {number} length The new length of the array.\n */\nvar truncateArray = function truncateArray(arr, length) {\n  while (arr.length > length) {\n    arr.pop();\n  }\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {!Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n * @return {void} Nothing.\n */\nvar attr = function attr(name, value) {\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} The Element's tag.\n * @return {void} Nothing.\n */\nvar elementClose = function elementClose(nameOrCtor) {\n  if (typeof nameOrCtor === 'function') {\n    new nameOrCtor();\n    return;\n  }\n  exports.buffer.push('</' + nameOrCtor + '>');\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n *\n * @param {string} The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {void} Nothing.\n */\nvar elementVoid = function elementVoid(nameOrCtor, key, statics, var_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(nameOrCtor);\n};\n\n/**\n * @param {!string} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {void} Nothing.\n */\nvar elementOpen = function elementOpen(nameOrCtor, key, statics, var_args) {\n  if (typeof nameOrCtor === 'function') {\n    new nameOrCtor();\n    return exports.currentParent;\n  }\n\n  exports.buffer.push('<' + nameOrCtor);\n\n  if (statics) {\n    for (var _i = 0; _i < statics.length; _i += 2) {\n      var name = /** @type {string} */statics[_i];\n      var value = statics[_i + 1];\n      updateAttribute(exports.buffer, name, value);\n    }\n  }\n\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    var _name = arguments[i];\n    var _value = arguments[i + 1];\n    updateAttribute(exports.buffer, _name, _value);\n  }\n\n  exports.buffer.push('>');\n\n  return exports.currentParent;\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n *\n * @return {void} Nothing.\n */\nvar elementOpenEnd = function elementOpenEnd() {\n  elementOpen.apply(null, argsBuilder);\n  truncateArray(argsBuilder, 0);\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {void} Nothing.\n */\nvar elementOpenStart = function elementOpenStart(nameOrCtor, key, statics) {\n  argsBuilder[0] = nameOrCtor;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/**\n * Returns the constructred DOM string at this point.\n * @param {function} fn\n * @return {string} The constructed DOM string.\n */\nvar renderToString = function renderToString(fn) {\n  patch({}, fn);\n  return currentElement().innerHTML;\n};\n\nexports.currentElement = currentElement;\nexports.currentPointer = currentPointer;\nexports.patch = patch;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.text = text;\nexports.attr = attr;\nexports.elementClose = elementClose;\nexports.elementOpen = elementOpen;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpenStart = elementOpenStart;\nexports.elementVoid = elementVoid;\nexports.renderToString = renderToString;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.updateAttribute = updateAttribute;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}