{"version":3,"sources":["IncrementalDomRenderer.js"],"names":["IncrementalDomRenderer","changes","props","component","data","ref","config","owner","components","childComponents","i","length","child","isDisposed","element","dispose","key","node","opt_dataOrElement","opt_parent","patch","render","IncrementalDOM","elementVoid","shouldRender","wasRendered","shouldUpdate","currentPointer","skipRender","context","refs","getInitialConfig","buildShouldUpdateArgs","skipNode","constructor","renderer","RENDERER_NAME"],"mappings":"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","file":"IncrementalDomRenderer.js","sourcesContent":["'use strict';\n\nimport './incremental-dom';\nimport { getChanges, trackChanges } from './changes';\nimport { clearData, getData } from './data';\nimport { getOwner } from './children/children';\nimport { getPatchingComponent, patch } from './render/patch';\nimport { render, renderChild, renderFunction } from './render/render';\nimport { Component, ComponentRenderer } from 'metal-component';\n\nclass IncrementalDomRenderer extends ComponentRenderer.constructor {\n\t/**\n\t * Returns an array with the args that should be passed to the component's\n\t * `shouldUpdate` method. This can be overridden by sub classes to change\n\t * what the method should receive.\n\t * @param {Object} changes\n\t * @return {!Array}\n\t */\n\tbuildShouldUpdateArgs(changes) {\n\t\treturn [changes.props];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdispose(component) {\n\t\tconst data = getData(component);\n\t\tconst ref = data.config.ref;\n\t\tconst owner = data.owner;\n\t\tif (owner && owner.components && owner.components[ref] === component) {\n\t\t\tdelete owner.components[ref];\n\t\t}\n\n\t\tif (data.childComponents) {\n\t\t\tfor (let i = 0; i < data.childComponents.length; i++) {\n\t\t\t\tconst child = data.childComponents[i];\n\t\t\t\tif (!child.isDisposed()) {\n\t\t\t\t\tchild.element = null;\n\t\t\t\t\tchild.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclearData(component);\n\t}\n\n\t/**\n\t * Generates a key for the element currently being rendered in the given\n\t * component. By default, just returns the original key. Sub classes can\n\t * override this to change the behavior.\n\t * @param {!Component} component\n\t * @param {string} key\n\t * @return {?string}\n\t */\n\tgenerateKey(component, key) {\n\t\treturn key;\n\t}\n\n\t/**\n\t * Get the component's config data.\n\t * @param {!Component} component\n\t * @return {!Object}\n\t */\n\tgetConfig(component) {\n\t\treturn getData(component).config;\n\t}\n\n\t/**\n\t * Get the component's incremental dom renderer data.\n\t * @param {!Component} component\n\t * @return {!Object}\n\t */\n\tgetData(component) {\n\t\treturn getData(component);\n\t}\n\n\t/**\n\t * Gets the component that triggered the current patch operation.\n\t * @return {Component}\n\t */\n\tgetPatchingComponent() {\n\t\treturn getPatchingComponent();\n\t}\n\n\t/**\n\t * Handles a node having just been rendered. Sub classes should override this\n\t * for custom behavior.\n\t */\n\thandleNodeRendered() {}\n\n\t/**\n\t * Checks if the given object is an incremental dom node.\n\t * @param {!Object} node\n\t * @return {boolean}\n\t */\n\tisIncDomNode(node) {\n\t\treturn !!getOwner(node);\n\t}\n\n\t/**\n\t * Calls incremental dom's patch function to render the component.\n\t * @param {!Component} component\n\t */\n\tpatch(component) {\n\t\tpatch(component);\n\t}\n\n\t/**\n\t * Renders the renderer's component for the first time, patching its element\n\t * through incremental dom function calls. If the first arg is a function\n\t * instead of a component instance, creates and renders this function, which\n\t * can either be a simple incremental dom function or a component constructor.\n\t * @param {!Component} component\n\t * @param {!Component|function()} component Can be a component instance, a\n\t *     simple incremental dom function or a component constructor.\n\t * @param {Object|Element=} opt_dataOrElement Optional config data for the\n\t *     function, or parent for the rendered content.\n\t * @param {Element=} opt_parent Optional parent for the rendered content.\n\t * @return {!Component} The rendered component's instance.\n\t */\n\trender(component, opt_dataOrElement, opt_parent) {\n\t\tif (component instanceof Component) {\n\t\t\tthis.patch(component);\n\t\t} else {\n\t\t\treturn renderFunction(this, component, opt_dataOrElement, opt_parent);\n\t\t}\n\t}\n\n\t/**\n\t * Renders the given child node via its owner renderer.\n\t * @param {!Object} child\n\t */\n\trenderChild(child) {\n\t\trenderChild(child);\n\t}\n\n\t/**\n\t * Calls functions from `IncrementalDOM` to build the component element's\n\t * content. Can be overriden by subclasses (for integration with template\n\t * engines for example).\n\t * @param {!Component} component\n\t */\n\trenderIncDom(component) {\n\t\tif (component.render) {\n\t\t\tcomponent.render();\n\t\t} else {\n\t\t\tIncrementalDOM.elementVoid('div');\n\t\t}\n\t}\n\n\t/**\n\t * Runs the incremental dom functions for rendering this component, without\n\t * calling `patch`. This function needs to be called inside a `patch`.\n\t * @param {!Component} component\n\t */\n\trenderInsidePatch(component) {\n\t\tconst shouldRender = !component.wasRendered ||\n\t\t\tthis.shouldUpdate(component, getChanges(component)) ||\n\t\t\tIncrementalDOM.currentPointer() !== component.element;\n\t\tif (shouldRender) {\n\t\t\trender(component);\n\t\t} else if (component.element) {\n\t\t\tthis.skipRender();\n\t\t}\n\t}\n\n\t/**\n\t * Sets up this component to be used by this renderer.\n\t * @param {!Component} component\n\t */\n\tsetUp(component) {\n\t\tcomponent.context = {};\n\t\tcomponent.components = {};\n\t\tcomponent.refs = {};\n\n\t\tconst data = getData(component);\n\t\tdata.config = component.getInitialConfig();\n\t\ttrackChanges(component);\n\t}\n\n\t/**\n\t * Checks if the component should be updated with the current state changes.\n\t * @param {!Component} component\n\t * @param {Object} changes\n\t * @return {boolean}\n\t */\n\tshouldUpdate(component, changes) {\n\t\tif (!changes) {\n\t\t\treturn false;\n\t\t}\n\t\tif (component.shouldUpdate) {\n\t\t\treturn component.shouldUpdate(...this.buildShouldUpdateArgs(changes));\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Skips the next disposal of children components, by clearing the array as\n\t * if there were no children rendered the last time. This can be useful for\n\t * allowing components to be reused by other parent components in separate\n\t * render update cycles.\n\t * @param {!Component} component\n\t */\n\tskipNextChildrenDisposal(component) {\n\t\tgetData(component).childComponents = null;\n\t}\n\n\t/**\n\t * Skips rendering the current node.\n\t */\n\tskipRender() {\n\t\tIncrementalDOM.skipNode();\n\t}\n\n\t/**\n\t * Updates the renderer's component when state changes, patching its element\n\t * through incremental dom function calls.\n\t * @param {!Component} component\n\t */\n\tupdate(component) {\n\t\tif (this.shouldUpdate(component, getChanges(component))) {\n\t\t\tthis.patch(component);\n\t\t}\n\t}\n}\n\nconst renderer = new IncrementalDomRenderer();\n\n// Name of this renderer. Renderers should provide this as a way to identify\n// them via a simple string (when calling enableCompatibilityMode to add\n// support to old features for specific renderers for example).\nrenderer.RENDERER_NAME = 'incremental-dom';\n\nexport default renderer;\n"]}